{
  "id": "guide/router",
  "title": "In-app navigation: routing to views",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/router.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"in-app-navigation-routing-to-views\" translation-result=\"on\">应用内导航：路由到视图<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#in-app-navigation-routing-to-views\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"in-app-navigation-routing-to-views\">In-app navigation: routing to views<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#in-app-navigation-routing-to-views\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">在单页面应用中，你可以通过显示或隐藏特定组件的显示部分来改变用户能看到的内容，而不用去服务器获取新页面。当用户执行应用任务时，他们要在你预定义的不同<a href=\"guide/glossary#view\" title=\"视图的定义\">视图</a>之间移动。要想在应用的单个页面中实现这种导航，你可以使用 Angular 的<strong><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code></strong>（路由器）。</p><p translation-origin=\"off\">In a single-page app, you change what the user sees by showing or hiding portions of the display that correspond to particular components, rather than going out to the server to get a new page.\nAs users perform application tasks, they need to move between the different <a href=\"guide/glossary#view\" title=\"Definition of view\">views</a> that you have defined.</p>\n\n<p translation-result=\"on\">为了处理从一个<a href=\"guide/glossary#view\">视图</a>到下一个视图之间的导航，你可以使用 Angular 的<em>路由器</em>。路由器会把浏览器 URL 解释成改变视图的操作指南，以完成导航。</p><p translation-origin=\"off\">To handle the navigation from one <a href=\"guide/glossary#view\">view</a> to the next, you use the Angular <strong><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code></strong>.\nThe <strong><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code></strong> enables navigation by interpreting a browser URL as an instruction to change the view.</p>\n\n<p translation-result=\"on\">要探索一个具备路由器主要功能的范例应用，请参阅<live-example></live-example>。</p><p translation-origin=\"off\">To explore a sample app featuring the router's primary features, see the <live-example></live-example>.</p>\n\n<h2 id=\"prerequisites\" translation-result=\"on\">先决条件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#prerequisites\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"prerequisites\">Prerequisites<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在创建路由之前，你应该熟悉以下内容：</p><p translation-origin=\"off\">Before creating a route, you should be familiar with the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"guide/architecture-components\">组件的基础知识</a></p><p translation-origin=\"off\"><a href=\"guide/architecture-components\">Basics of components</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/glossary#template\">模板的基础知识</a></p><p translation-origin=\"off\"><a href=\"guide/glossary#template\">Basics of templates</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\">一个 Angular 应用，你可以使用 <a href=\"cli\">Angular CLI</a> 生成一个基本的 Angular 应用。</p><p translation-origin=\"off\">An Angular app—you can generate a basic Angular app using the <a href=\"cli\">Angular CLI</a>.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">关于这个现成应用的 Angular 简介，请参阅<a href=\"start\">快速上手</a>。关于构建 Angular 应用的更深入体验，请参阅<a href=\"tutorial\">英雄之旅</a>教程。两者都会指导你使用组件类和模板。</p><p translation-origin=\"off\">For an introduction to Angular with a ready-made app, see <a href=\"start\">Getting Started</a>.\nFor a more in-depth experience of building an Angular app, see the <a href=\"tutorial\">Tour of Heroes</a> tutorial. Both guide you through using component classes and templates.</p>\n\n<a id=\"basics\"></a>\n<h2 id=\"generate-an-app-with-routing-enabled\" translation-result=\"on\">生成一个支持路由的应用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#generate-an-app-with-routing-enabled\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"generate-an-app-with-routing-enabled\">Generate an app with routing enabled<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#generate-an-app-with-routing-enabled\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">下面的命令会用 Angular CLI 来生成一个带有应用路由模块（<code>AppRoutingModule</code>）的基本 Angular 应用，它是一个 NgModule，可用来配置路由。下面的例子中应用的名字是 <code>routing-app</code>。</p><p translation-origin=\"off\">The following command uses the Angular CLI to generate a basic Angular app with an app routing module, called <code>AppRoutingModule</code>, which is an NgModule where you can configure your routes.\nThe app name in the following example is <code>routing-app</code>.</p>\n\n<code-example language=\"sh\">\n  ng new routing-app --routing\n</code-example>\n<p translation-result=\"on\">一旦生成新应用，CLI 就会提示你选择 CSS 或 CSS 预处理器。在这个例子中，我们接受 <code>CSS</code> 的默认值。</p><p translation-origin=\"off\">When generating a new app, the CLI prompts you to select CSS or a CSS preprocessor.\nFor this example, accept the default of <code>CSS</code>.</p>\n\n<h3 id=\"adding-components-for-routing\" translation-result=\"on\">为路由添加组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#adding-components-for-routing\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"adding-components-for-routing\">Adding components for routing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#adding-components-for-routing\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">为了使用 Angular 的路由器，应用至少要有两个组件才能从一个导航到另一个。要使用 CLI 创建组件，请在命令行输入以下内容，其中 <code>first</code> 是组件的名称：</p><p translation-origin=\"off\">To use the Angular router, an app needs to have at least two components so that it can navigate from one to the other. To create a component using the CLI, enter the following at the command line where <code>first</code> is the name of your component:</p>\n\n<code-example language=\"sh\">\n  ng generate component first\n</code-example>\n<p translation-result=\"on\">为第二个组件重复这个步骤，但给它一个不同的名字。这里的新名字是 <code>second</code>。</p><p translation-origin=\"off\">Repeat this step for a second component but give it a different name.\nHere, the new name is <code>second</code>.</p>\n\n<code-example language=\"sh\">\n  ng generate component second\n</code-example>\n<p translation-result=\"on\">CLI 会自动添加 <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 后缀，所以如果在编写 <code>first-component</code>，那么其组件名就是 <code>FirstComponentComponent</code>。</p><p translation-origin=\"off\">The CLI automatically appends <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>, so if you were to write <code>first-component</code>, your component would be <code>FirstComponentComponent</code>.</p>\n\n<a id=\"basics-base-href\"></a>\n<div class=\"alert is-helpful\">\n<h4 id=\"base-href\"><code>&#x3C;base href></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#base-href\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">  本指南适用于 CLI 生成的 Angular 应用。如果你是手动工作的，请确保你的 index.html 文件的 <code>&#x3C;head></code> 中有 <code>&#x3C;base href=\"/\"></code> 语句。这里假定 <code>app</code> 文件夹是应用的根目录，并使用 <code>\"/\"</code> 作为基础路径。</p><p translation-origin=\"off\">  This guide works with a CLI-generated Angular app.\nIf you are working manually, make sure that you have <code>&#x3C;base href=\"/\"></code> in the <code>&#x3C;head></code> of your index.html file.\nThis assumes that the <code>app</code> folder is the application root, and uses <code>\"/\"</code>.</p>\n\n</div>\n<h3 id=\"importing-your-new-components\" translation-result=\"on\">导入这些新组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#importing-your-new-components\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"importing-your-new-components\">Importing your new components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#importing-your-new-components\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要使用这些新组件，请把它们导入到该文件顶部的 <code>AppRoutingModule</code> 中，具体如下：</p><p translation-origin=\"off\">To use your new components, import them into <code>AppRoutingModule</code> at the top of the file, as follows:</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\">\n\nimport { FirstComponent } from './first/first.component';\nimport { SecondComponent } from './second/second.component';\n\n</code-example>\n<a id=\"basic-route\"></a>\n<h2 id=\"defining-a-basic-route\" translation-result=\"on\">定义一个基本路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#defining-a-basic-route\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"defining-a-basic-route\">Defining a basic route<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#defining-a-basic-route\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">创建路由有三个基本的构建块。</p><p translation-origin=\"off\">There are three fundamental building blocks to creating a route.</p>\n\n<p translation-result=\"on\">把 <code>AppRoutingModule</code> 导入 <code>AppModule</code> 并把它添加到 <code>imports</code> 数组中。</p><p translation-origin=\"off\">Import the <code>AppRoutingModule</code> into <code>AppModule</code> and add it to the <code>imports</code> array.</p>\n\n<p translation-result=\"on\">Angular CLI 会为你执行这一步骤。但是，如果要手动创建应用或使用现存的非 CLI 应用，请验证导入和配置是否正确。下面是使用 <code>--routing</code> 标志生成的默认 <code>AppModule</code>。</p><p translation-origin=\"off\">The Angular CLI performs this step for you.\nHowever, if you are creating an app manually or working with an existing, non-CLI app, verify that the imports and configuration are correct.\nThe following is the default <code>AppModule</code> using the CLI with the <code>--routing</code> flag.</p>\n\n<code-example path=\"router/src/app/app.module.8.ts\" header=\"Default CLI AppModule with routing\">\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { AppRoutingModule } from './app-routing.module'; // CLI imports AppRoutingModule\nimport { AppComponent } from './app.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    AppRoutingModule // CLI adds AppRoutingModule to the AppModule's imports array\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n\n</code-example>\n<ol>\n<li>\n<p translation-result=\"on\">把 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 和 <code><a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a></code> 导入到你的路由模块中。</p><p translation-origin=\"off\">Import <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> and <code><a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a></code> into your routing module.</p>\n\n<p translation-result=\"on\">Angular CLI 会自动执行这一步骤。CLI 还为你的路由设置了 <code><a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a></code> 数组，并为 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 配置了 <code>imports</code> 和 <code>exports</code> 数组。</p><p translation-origin=\"off\">The Angular CLI performs this step automatically.\nThe CLI also sets up a <code><a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a></code> array for your routes and configures the <code>imports</code> and <code>exports</code> arrays for <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code>.</p>\n\n<code-example path=\"router/src/app/app-routing.module.7.ts\" header=\"CLI app routing module\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router'; // CLI imports router\n\nconst routes: <a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a> = []; // sets up routes constant where you define your routes\n\n// configures <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> imports and exports\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">在 <code><a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a></code> 数组中定义你的路由。</p><p translation-origin=\"off\">Define your routes in your <code><a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a></code> array.</p>\n\n<p translation-result=\"on\">这个数组中的每个路由都是一个包含两个属性的 JavaScript 对象。第一个属性 <code>path</code> 定义了该路由的 URL 路径。第二个属性 <code>component</code> 定义了要让 Angular 用作相应路径的组件。</p><p translation-origin=\"off\">Each route in this array is a JavaScript object that contains two properties.\nThe first property, <code>path</code>, defines the URL path for the route.\nThe second property, <code>component</code>, defines the component Angular should use for the corresponding path.</p>\n\n</li>\n</ol>\n<code-example path=\"router/src/app/app-routing.module.8.ts\" region=\"routes\" header=\"AppRoutingModule (excerpt)\">\nconst routes: <a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a> = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n];\n\n</code-example>\n<ol>\n<li>\n<p translation-result=\"on\">把这些路由添加到你的应用中。</p><p translation-origin=\"off\">Add your routes to your application.</p>\n\n<p translation-result=\"on\">现在你已经定义了路由，可以把它们添加到应用中了。首先，添加到这两个组件的链接。把要添加路由的链接赋值给 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 属性。将属性的值设置为该组件，以便在用户点击各个链接时显示这个值。接下来，修改组件模板以包含 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> 标签。该元素会通知 Angular，你可以用所选路由的组件更新应用的视图。</p><p translation-origin=\"off\">Now that you have defined your routes, you can add them to your application.\nFirst, add links to the two components.\nAssign the anchor tag that you want to add the route to the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> attribute.\nSet the value of the attribute to the component to show when a user clicks on each link.\nNext, update your component template to include <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>.\nThis element informs Angular to update the application view with the component for the selected route.</p>\n\n<code-example path=\"router/src/app/app.component.7.html\" header=\"Template with routerLink and router-outlet\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> App&#x3C;/h1>\n&#x3C;!-- This nav gives you links to click, which tells the router which route to use (defined in the routes constant in  AppRoutingModule) -->\n&#x3C;nav>\n  &#x3C;ul>\n    &#x3C;li>&#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/first-component\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">First <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&#x3C;/a>&#x3C;/li>\n    &#x3C;li>&#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/second-component\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Second <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&#x3C;/a>&#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/nav>\n&#x3C;!-- The routed views render in the &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>-->\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n\n</code-example>\n</li>\n</ol>\n<a id=\"route-order\"></a>\n<h3 id=\"route-order\" translation-result=\"on\">路由顺序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#route-order\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"route-order\">Route order<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#route-order\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">路由的顺序很重要，因为 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 在匹配路由时使用“先到先得”策略，所以应该在不那么具体的路由前面放置更具体的路由。首先列出静态路径的路由，然后是一个与默认路由匹配的空路径路由。<a href=\"guide/router#setting-up-wildcard-routes\">通配符路由</a>是最后一个，因为它匹配每一个 URL，只有当其它路由都没有匹配时，<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 才会选择它。</p><p translation-origin=\"off\">The order of routes is important because the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> uses a first-match wins strategy when matching routes, so more specific routes should be placed above less specific routes.\nList routes with a static path first, followed by an empty path route, which matches the default route.\nThe <a href=\"guide/router#setting-up-wildcard-routes\">wildcard route</a> comes last because it matches every URL and the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>  selects it only if no other routes match first.</p>\n\n<a id=\"getting-route-information\"></a>\n<h2 id=\"getting-route-information\" translation-result=\"on\">获取路由信息<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#getting-route-information\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"getting-route-information\">Getting route information<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#getting-route-information\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">通常，当用户导航你的应用时，你会希望把信息从一个组件传递到另一个组件。例如，考虑一个显示杂货商品购物清单的应用。列表中的每一项都有一个唯一的 <code>id</code>。要想编辑某个项目，用户需要单击“编辑”按钮，打开一个 <code>EditGroceryItem</code> 组件。你希望该组件得到该商品的 <code>id</code>，以便它能向用户显示正确的信息。</p><p translation-origin=\"off\">Often, as a user navigates your application, you want to pass information from one component to another.\nFor example, consider an application that displays a shopping list of grocery items.\nEach item in the list has a unique <code>id</code>.\nTo edit an item, users click an Edit button, which opens an <code>EditGroceryItem</code> component.\nYou want that component to retrieve the <code>id</code> for the grocery item so it can display the right information to the user.</p>\n\n<p translation-result=\"on\">你也可以使用一个路由把这种类型的信息传给你的应用组件。要做到这一点，你可以使用 <a href=\"api/router/ActivatedRoute\">ActivatedRoute</a> 接口。</p><p translation-origin=\"off\">You can use a route to pass this type of information to your application components.\nTo do so, you use the <a href=\"api/router/ActivatedRoute\">ActivatedRoute</a> interface.</p>\n\n<p translation-result=\"on\">要从路由中获取信息：</p><p translation-origin=\"off\">To get information from a route:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">把 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 和 <code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> 导入你的组件。</p><p translation-origin=\"off\">Import <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> and <code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> to your component.</p>\n\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.ts\" region=\"imports-route-info\" header=\"In the component class (excerpt)\">\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\n\n</code-example>\n<p translation-result=\"on\">这些 <code>import</code> 语句添加了组件所需的几个重要元素。要详细了解每个 API，请参阅以下 API 页面：</p><p translation-origin=\"off\">These <code>import</code> statements add several important elements that your component needs.\nTo learn more about each, see the following API pages:</p>\n\n<ul>\n<li><a href=\"api/router\"><code>Router</code></a></li>\n<li><a href=\"api/router/ActivatedRoute\"><code>ActivatedRoute</code></a></li>\n<li><a href=\"api/router/ParamMap\"><code>ParamMap</code></a></li>\n</ul>\n</li>\n<li>\n<p translation-result=\"on\">通过把 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 的一个实例添加到你的应用的构造函数中来注入它：</p><p translation-origin=\"off\">Inject an instance of <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> by adding it to your application's constructor:</p>\n\n<code-example path=\"router/src/app/heroes/hero-detail/hero-detail.component.ts\" region=\"activated-route\" header=\"In the component class (excerpt)\">\nconstructor(\n  private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n) {}\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">更新 <code>ngOnInit()</code> 方法来访问这个 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 并跟踪 <code>id</code> 参数：</p><p translation-origin=\"off\">Update the <code>ngOnInit()</code> method to access the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> and track the <code>id</code> parameter:</p>\n\n  <code-example header=\"In the component (excerpt)\">\n    ngOnInit() {\n      this.route.queryParams.subscribe(params => {\n        this.name = params['name'];\n      });\n    }\n  </code-example>\n<p translation-result=\"on\">注意：前面的例子使用了一个变量 <code>name</code>，并根据 <code>name</code> 参数给它赋值。</p><p translation-origin=\"off\">Note: The preceding example uses a variable, <code>name</code>, and assigns it the value based on the <code>name</code> parameter.</p>\n\n</li>\n</ol>\n<a id=\"wildcard-route-how-to\"></a>\n<h2 id=\"setting-up-wildcard-routes\" translation-result=\"on\">设置通配符路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-up-wildcard-routes\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"setting-up-wildcard-routes\">Setting up wildcard routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-up-wildcard-routes\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当用户试图导航到那些不存在的应用部件时，在正常的应用中应该能得到很好的处理。要在应用中添加此功能，需要设置通配符路由。当所请求的 URL 与任何路由器路径都不匹配时，Angular 路由器就会选择这个路由。</p><p translation-origin=\"off\">A well-functioning application should gracefully handle when users attempt to navigate to a part of your application that does not exist.\nTo add this functionality to your application, you set up a wildcard route.\nThe Angular router selects this route any time the requested URL doesn't match any router paths.</p>\n\n<p translation-result=\"on\">要设置通配符路由，请在 <code>routes</code> 定义中添加以下代码。</p><p translation-origin=\"off\">To set up a wildcard route, add the following code to your <code>routes</code> definition.</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\">\n\n{ path: '**', component: <component-name> }\n\n</component-name></code-example>\n<p translation-result=\"on\">这两个星号 <code>**</code> 告诉 Angular，这个 <code>routes</code> 定义是通配符路由。对于 component 属性，你可以使用应用中的任何组件。常见的选择包括应用专属的 <code>PageNotFoundComponent</code>，你可以定义它来向用户<a href=\"guide/router#404-page-how-to\">展示 404 页面</a>，或者跳转到应用的主组件。通配符路由是最后一个路由，因为它匹配所有的 URL。关于路由顺序的更多详细信息，请参阅<a href=\"guide/router#route-order\">路由顺序</a>。</p><p translation-origin=\"off\">The two asterisks, <code>**</code>, indicate to Angular that this <code>routes</code> definition is a wildcard route.\nFor the component property, you can define any component in your application.\nCommon choices include an application-specific <code>PageNotFoundComponent</code>, which you can define to <a href=\"guide/router#404-page-how-to\">display a 404 page</a> to your users; or a redirect to your application's main component.\nA wildcard route is the last route because it matches any URL.\nFor more detail on why order matters for routes, see <a href=\"guide/router#route-order\">Route order</a>.</p>\n\n<a id=\"404-page-how-to\"></a>\n<h2 id=\"displaying-a-404-page\" translation-result=\"on\">显示 404 页面<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#displaying-a-404-page\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"displaying-a-404-page\">Displaying a 404 page<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#displaying-a-404-page\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要显示 404 页面，请设置一个<a href=\"guide/router#wildcard-route-how-to\">通配符路由</a>，并将 <code>component</code> 属性设置为你要用于 404 页面的组件，如下所示：</p><p translation-origin=\"off\">To display a 404 page, set up a <a href=\"guide/router#wildcard-route-how-to\">wildcard route</a> with the <code>component</code> property set to the component you'd like to use for your 404 page as follows:</p>\n\n<code-example path=\"router/src/app/app-routing.module.8.ts\" region=\"routes-with-wildcard\" header=\"AppRoutingModule (excerpt)\">\nconst routes: <a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a> = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];\n\n</code-example>\n<p translation-result=\"on\"><code>path</code> 为 <code>**</code> 的最后一条路由是通配符路由。如果请求的 URL 与前面列出的路径不匹配，路由器会选择这个路由，并把该用户送到 <code>PageNotFoundComponent</code>。</p><p translation-origin=\"off\">The last route with the <code>path</code> of <code>**</code> is a wildcard route.\nThe router selects this route if the requested URL doesn't match any of the paths earlier in the list and sends the user to the <code>PageNotFoundComponent</code>.</p>\n\n<h2 id=\"setting-up-redirects\" translation-result=\"on\">设置重定向<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-up-redirects\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"setting-up-redirects\">Setting up redirects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-up-redirects\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要设置重定向，请使用重定向源的 <code>path</code>、要重定向目标的 <code>component</code> 和一个 <code>pathMatch</code> 值来配置路由，以告诉路由器该如何匹配 URL。</p><p translation-origin=\"off\">To set up a redirect, configure a route with the <code>path</code> you want to redirect from, the <code>component</code> you want to redirect to, and a <code>pathMatch</code> value that tells the router how to match the URL.</p>\n\n<code-example path=\"router/src/app/app-routing.module.8.ts\" region=\"redirect\" header=\"AppRoutingModule (excerpt)\">\nconst routes: <a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a> = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '',   redirectTo: '/first-component', pathMatch: 'full' }, // redirect to `first-component`\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];\n\n</code-example>\n<p translation-result=\"on\">在这个例子中，第三个路由是重定向路由，所以路由器会默认跳到 <code>first-component</code> 路由。注意，这个重定向路由位于通配符路由之前。这里的 <code>path: ''</code> 表示使用初始的相对 URL（ <code>''</code> ）。</p><p translation-origin=\"off\">In this example, the third route is a redirect so that the router defaults to the <code>first-component</code> route.\nNotice that this redirect precedes the wildcard route.\nHere, <code>path: ''</code> means to use the initial relative URL (<code>''</code>).</p>\n\n<p translation-result=\"on\">关于 <code>pathMatch</code> 的详情，请参阅<a href=\"guide/router-tutorial-toh#pathmatch\">聚焦 <code>pathMatch</code></a>部分。</p><p translation-origin=\"off\">For more details on <code>pathMatch</code> see <a href=\"guide/router-tutorial-toh#pathmatch\">Spotlight on <code>pathMatch</code></a>.</p>\n\n<a id=\"nesting-routes\"></a>\n<h2 id=\"nesting-routes\" translation-result=\"on\">嵌套路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#nesting-routes\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"nesting-routes\">Nesting routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#nesting-routes\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">随着你的应用变得越来越复杂，你可能要创建一些根组件之外的相对路由。这些嵌套路由类型称为子路由。这意味着你要为你的应用添加第二 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>，因为它是 <code>AppComponent</code> 之外的另一个 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>。</p><p translation-origin=\"off\">As your application grows more complex, you may want to create routes that are relative to a component other than your root component.\nThese types of nested routes are called child routes.\nThis means you're adding a second <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> to your app, because it is in addition to the <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> in <code>AppComponent</code>.</p>\n\n<p translation-result=\"on\">在这个例子中，还有两个子组件，<code>child-a</code> 和 <code>child-b</code>。这里的 <code>FirstComponent</code> 有它自己的 <code>&#x3C;nav></code> 和 <code>AppComponent</code> 之外的第二 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>。</p><p translation-origin=\"off\">In this example, there are two additional child components, <code>child-a</code>, and <code>child-b</code>.\nHere, <code>FirstComponent</code> has its own <code>&#x3C;nav></code> and a second <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> in addition to the one in <code>AppComponent</code>.</p>\n\n<code-example path=\"router/src/app/app.component.8.html\" region=\"child-routes\" header=\"In the template\">\n&#x3C;h2>First <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&#x3C;/h2>\n\n&#x3C;nav>\n  &#x3C;ul>\n    &#x3C;li>&#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"child-a\">Child A&#x3C;/a>&#x3C;/li>\n    &#x3C;li>&#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"child-b\">Child B&#x3C;/a>&#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/nav>\n\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<p translation-result=\"on\">子路由和其它路由一样，同时需要 <code>path</code> 和 <code>component</code>。唯一的区别是你要把子路由放在父路由的 <code>children</code> 数组中。</p><p translation-origin=\"off\">A child route is like any other route, in that it needs both a <code>path</code> and a <code>component</code>.\nThe one difference is that you place child routes in a <code>children</code> array within the parent route.</p>\n\n<code-example path=\"router/src/app/app-routing.module.9.ts\" region=\"child-routes\" header=\"AppRoutingModule (excerpt)\">\nconst routes: <a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'first-component',\n    component: FirstComponent, // this is the component with the &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>> in the template\n    children: [\n      {\n        path: 'child-a', // child route path\n        component: ChildAComponent, // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        component: ChildBComponent, // another child route component that the router renders\n      },\n    ],\n  },\n];\n\n</code-example>\n<a id=\"using-relative-paths\"></a>\n<h2 id=\"using-relative-paths\" translation-result=\"on\">使用相对路径<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#using-relative-paths\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"using-relative-paths\">Using relative paths<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#using-relative-paths\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">相对路径允许你定义相对于当前 URL 段的路径。下面的例子展示了到另一个组件 <code>second-component</code> 的相对路由。<code>FirstComponent</code> 和 <code>SecondComponent</code> 在树中处于同一级别，但是，指向 <code>SecondComponent</code> 的链接位于 <code>FirstComponent</code> 中，这意味着路由器必须先上升一个级别，然后进入二级目录才能找到 <code>SecondComponent</code>。你可以使用 <code>../</code> 符号来上升一个级别，而不用写出到 <code>SecondComponent</code> 的完整路径。</p><p translation-origin=\"off\">Relative paths allow you to define paths that are relative to the current URL segment.\nThe following example shows a relative route to another component, <code>second-component</code>.\n<code>FirstComponent</code> and <code>SecondComponent</code> are at the same level in the tree, however, the link to <code>SecondComponent</code> is situated within the <code>FirstComponent</code>, meaning that the router has to go up a level and then into the second directory to find the <code>SecondComponent</code>.\nRather than writing out the whole path to get to <code>SecondComponent</code>, you can use the <code>../</code> notation to go up a level.</p>\n\n<code-example path=\"router/src/app/app.component.8.html\" region=\"relative-route\" header=\"In the template\">\n\n&#x3C;h2>First <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&#x3C;/h2>\n\n&#x3C;nav>\n  &#x3C;ul>\n    &#x3C;li>&#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"../second-component\">Relative <a href=\"api/router/Route\" class=\"code-anchor\">Route</a> to second component&#x3C;/a>&#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n\n</code-example>\n<p translation-result=\"on\">除了 <code>../</code>，还可以使用 <code>./</code> 或者不带前导斜杠来指定当前级别。</p><p translation-origin=\"off\">In addition to <code>../</code>, you can use <code>./</code> or no leading slash to specify the current level.</p>\n\n<h3 id=\"specifying-a-relative-route\" translation-result=\"on\">指定相对路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#specifying-a-relative-route\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"specifying-a-relative-route\">Specifying a relative route<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#specifying-a-relative-route\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要指定相对路由，请使用 <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> 中的 <code>relativeTo</code> 属性。在组件类中，从 <code>@angular/router</code> 导入 <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code>。</p><p translation-origin=\"off\">To specify a relative route, use the <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> <code>relativeTo</code> property.\nIn the component class, import <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> from the <code>@angular/router</code>.</p>\n\n<p translation-result=\"on\">然后在导航方法中使用 <code>relativeTo</code> 参数。在链接参数数组（它包含 <code>items</code>）之后添加一个对象，把该对象的 <code>relativeTo</code> 属性设置为当前的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>，也就是 <code>this.route</code>。</p><p translation-origin=\"off\">Then use <code>relativeTo</code> in your navigation method.\nAfter the link parameters array, which here contains <code>items</code>, add an object with the <code>relativeTo</code> property set to the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>, which is <code>this.route</code>.</p>\n\n<code-example path=\"router/src/app/app.component.4.ts\" region=\"relative-to\" header=\"RelativeTo\">\ngoToItems() {\n  this.router.navigate(['items'], { relativeTo: this.route });\n}\n\n</code-example>\n<p translation-result=\"on\"><code>goToItems()</code> 方法会把目标 URI 解释为相对于当前路由的，并导航到 <code>items</code> 路由。</p><p translation-origin=\"off\">The <code>goToItems()</code> method interprets the destination URI as relative to the activated route and navigates to the <code>items</code> route.</p>\n\n<h2 id=\"accessing-query-parameters-and-fragments\" translation-result=\"on\">访问查询参数和片段<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#accessing-query-parameters-and-fragments\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"accessing-query-parameters-and-fragments\">Accessing query parameters and fragments<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#accessing-query-parameters-and-fragments\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">有时，应用中的某个特性需要访问路由的部件，比如查询参数或片段（fragment）。本教程的这个阶段使用了一个“英雄之旅”中的列表视图，你可以在其中点击一个英雄来查看详情。路由器使用 <code>id</code> 来显示正确的英雄的详情。</p><p translation-origin=\"off\">Sometimes, a feature of your application requires accessing a part of a route, such as a query parameter or a fragment. The Tour of Heroes app at this stage in the tutorial uses a list view in which you can click on a hero to see details. The router uses an <code>id</code> to show the correct hero's details.</p>\n\n<p translation-result=\"on\">首先，在要导航的组件中导入以下成员。</p><p translation-origin=\"off\">First, import the following members in the component you want to navigate from.</p>\n\n<code-example header=\"Component import statements (excerpt)\">\n\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n</code-example>\n<p translation-result=\"on\">接下来，注入当前路由（ActivatedRoute）服务：</p><p translation-origin=\"off\">Next inject the activated route service:</p>\n\n<code-example header=\"Component (excerpt)\">\nconstructor(private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>) {}\n</code-example>\n<p translation-result=\"on\">配置这个类，让你有一个可观察对象 <code>heroes$</code>、一个用来保存英雄的 <code>id</code> 号的 <code>selectedId</code>，以及 <code>ngOnInit()</code> 中的英雄们，添加下面的代码来获取所选英雄的 <code>id</code>。这个代码片段假设你有一个英雄列表、一个英雄服务、一个能获取你的英雄的函数，以及用来渲染你的列表和细节的 HTML，就像在《英雄之旅》例子中一样。</p><p translation-origin=\"off\">Configure the class so that you have an observable, <code>heroes$</code>, a <code>selectedId</code> to hold the <code>id</code> number of the hero, and the heroes in the <code>ngOnInit()</code>, add the following code to get the <code>id</code> of the selected hero.\nThis code snippet assumes that you have a heroes list, a hero service, a function to get your heroes, and the HTML to render your list and details, just as in the Tour of Heroes example.</p>\n\n<code-example header=\"Component 1 (excerpt)\">\n\nheroes$: Observable<hero[]>;\nselectedId: number;\nheroes = HEROES;\n\nngOnInit() {\n  this.heroes$ = this.route.paramMap.pipe(\n    switchMap(params => {\n      this.selectedId = Number(params.get('id'));\n      return this.service.getHeroes();\n    })\n  );\n}\n\n</hero[]></code-example>\n<p translation-result=\"on\">接下来，在要导航到的组件中，导入以下成员。</p><p translation-origin=\"off\">Next, in the component that you want to navigate to, import the following members.</p>\n\n<code-example header=\"Component 2 (excerpt)\">\n\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n</code-example>\n<p translation-result=\"on\">在组件类的构造函数中注入 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 和 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>，这样在这个组件中就可以用它们了：</p><p translation-origin=\"off\">Inject <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> and <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> in the constructor of the component class so they are available to this component:</p>\n\n<code-example header=\"Component 2 (excerpt)\">\n\n  hero$: Observable<hero>;\n\n  constructor(\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>  ) {}\n\n  ngOnInit() {\n    const heroId = this.route.snapshot.paramMap.get('id');\n    this.hero$ = this.service.getHero(heroId);\n  }\n\n  gotoItems(hero: Hero) {\n    const heroId = hero ? hero.id : null;\n    // Pass along the hero id if available\n    // so that the HeroList component can select that item.\n    this.router.navigate(['/heroes', { id: heroId }]);\n  }\n\n</hero></code-example>\n<a id=\"lazy-loading\"></a>\n<h2 id=\"lazy-loading\" translation-result=\"on\">惰性加载<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#lazy-loading\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"lazy-loading\">Lazy loading<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#lazy-loading\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以配置路由定义来实现惰性加载模块，这意味着 Angular 只会在需要时才加载这些模块，而不是在应用启动时就加载全部。\n另外，你可以在后台预加载一些应用部件来改善用户体验。</p><p translation-origin=\"off\">You can configure your routes to lazy load modules, which means that Angular only loads modules as needed, rather than loading all modules when the app launches.\nAdditionally, you can preload parts of your app in the background to improve the user experience.</p>\n\n<p translation-result=\"on\">关于惰性加载和预加载的详情，请参阅专门的指南<a href=\"guide/lazy-loading-ngmodules\">惰性加载 NgModule</a>。</p><p translation-origin=\"off\">For more information on lazy loading and preloading see the dedicated guide <a href=\"guide/lazy-loading-ngmodules\">Lazy loading NgModules</a>.</p>\n\n<h2 id=\"preventing-unauthorized-access\" translation-result=\"on\">防止未经授权的访问<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#preventing-unauthorized-access\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"preventing-unauthorized-access\">Preventing unauthorized access<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#preventing-unauthorized-access\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用路由守卫来防止用户未经授权就导航到应用的某些部分。Angular 中提供了以下路由守卫：</p><p translation-origin=\"off\">Use route guards to prevent users from navigating to parts of an app without authorization.\nThe following route guards are available in Angular:</p>\n\n<ul>\n<li><a href=\"api/router/CanActivate\"><code>CanActivate</code></a></li>\n<li><a href=\"api/router/CanActivateChild\"><code>CanActivateChild</code></a></li>\n<li><a href=\"api/router/CanDeactivate\"><code>CanDeactivate</code></a></li>\n<li><a href=\"api/router/Resolve\"><code>Resolve</code></a></li>\n<li><a href=\"api/router/CanLoad\"><code>CanLoad</code></a></li>\n</ul>\n<p translation-result=\"on\">要想使用路由守卫，可以考虑使用<a href=\"api/router/Route#componentless-routes\">无组件路由</a>，因为这对于保护子路由很方便。</p><p translation-origin=\"off\">To use route guards, consider using <a href=\"api/router/Route#componentless-routes\">component-less routes</a> as this facilitates guarding child routes.</p>\n\n<p translation-result=\"on\">为你的守卫创建一项服务：</p><p translation-origin=\"off\">Create a service for your guard:</p>\n\n<code-example language=\"sh\">\n  ng generate guard your-guard\n</code-example>\n<p translation-result=\"on\">请在守卫类里实现你要用到的守卫。下面的例子使用 <code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> 来保护该路由。</p><p translation-origin=\"off\">In your guard class, implement the guard you want to use.\nThe following example uses <code><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></code> to guard the route.</p>\n\n<code-example header=\"Component (excerpt)\">\nexport class YourGuard implements <a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a> {\n  canActivate(\n    next: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    state: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>): boolean {\n      // your  logic goes here\n  }\n}\n</code-example>\n<p translation-result=\"on\">在路由模块中，在 <code>routes</code> 配置中使用相应的属性。这里的 <code>canActivate</code> 会告诉路由器它要协调到这个特定路由的导航。</p><p translation-origin=\"off\">In your routing module, use the appropriate property in your <code>routes</code> configuration.\nHere, <code>canActivate</code> tells the router to mediate navigation to this particular route.</p>\n\n<code-example header=\"Routing module (excerpt)\">\n{\n  path: '/your-path',\n  component: YourComponent,\n  canActivate: [YourGuard],\n}\n</code-example>\n<p translation-result=\"on\">关于此可工作范例的更多信息，请参阅<a href=\"guide/router-tutorial-toh#milestone-5-route-guards\">路由导航中关于路由守卫的部分</a>。</p><p translation-origin=\"off\">For more information with a working example, see the <a href=\"guide/router-tutorial-toh#milestone-5-route-guards\">routing tutorial section on route guards</a>.</p>\n\n<h2 id=\"link-parameters-array\" translation-result=\"on\">链接参数数组<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#link-parameters-array\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"link-parameters-array\">Link parameters array<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#link-parameters-array\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">链接参数数组保存路由导航时所需的成分：</p><p translation-origin=\"off\">A link parameters array holds the following ingredients for router navigation:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> 指向目标组件的那个路由的路径（path）</p><p translation-origin=\"off\">The path of the route to the destination component.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 必备路由参数和可选路由参数，它们将进入该路由的 URL</p><p translation-origin=\"off\">Required and optional route parameters that go into the route URL.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">你可以把 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令绑定到一个数组，就像这样：</p><p translation-origin=\"off\">You can bind the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> directive to such an array like this:</p>\n\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (h-anchor)\" region=\"h-anchor\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/heroes']\">Heroes&#x3C;/a>\n\n</code-example>\n<p translation-result=\"on\">在指定路由参数时，使用如下的两元素数组：</p><p translation-origin=\"off\">The following is a two-element array when specifying a route parameter:</p>\n\n<code-example path=\"router/src/app/heroes/hero-list/hero-list.component.1.html\" header=\"src/app/heroes/hero-list/hero-list.component.html (nav-to-detail)\" region=\"nav-to-detail\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\">\n  &#x3C;span class=\"badge\">{{ hero.id }}&#x3C;/span>{{ hero.name }}\n&#x3C;/a>\n\n</code-example>\n<p translation-result=\"on\">你可以在对象中提供可选的路由参数，比如 <code>{ foo: 'foo' }</code> ：</p><p translation-origin=\"off\">You can provide optional route parameters in an object, as in <code>{ foo: 'foo' }</code>:</p>\n\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (cc-query-params)\" region=\"cc-query-params\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center', { foo: 'foo' }]\">Crisis Center&#x3C;/a>\n\n</code-example>\n<p translation-result=\"on\">这三个例子涵盖了你在单级路由的应用中所需的一切。不过，在你添加一个像<em>危机中心</em>一样的子路由时，你可以创建新链接数组。</p><p translation-origin=\"off\">These three examples cover the needs of an app with one level of routing.\nHowever, with a child router, such as in the crisis center, you create new link array possibilities.</p>\n\n<p translation-result=\"on\">下面这个最小化 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 例子是基于危机中心指定的<a href=\"guide/router-tutorial-toh#a-crisis-center-with-child-routes\">默认子路由</a>构建的。</p><p translation-origin=\"off\">The following minimal <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> example builds upon a specified <a href=\"guide/router-tutorial-toh#a-crisis-center-with-child-routes\">default child route</a> for the crisis center.</p>\n\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (cc-anchor-w-default)\" region=\"cc-anchor-w-default\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center']\">Crisis Center&#x3C;/a>\n\n</code-example>\n<p translation-result=\"on\">请注意以下事项：</p><p translation-origin=\"off\">Note the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> 数组中的第一个条目标记出了父路由(<code>/crisis-center</code>)。</p><p translation-origin=\"off\">The first item in the array identifies the parent route (<code>/crisis-center</code>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 这个父路由没有参数。</p><p translation-origin=\"off\">There are no parameters for this parent route.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 没有默认的子路由，因此你得选取一个。</p><p translation-origin=\"off\">There is no default for the child route so you need to pick one.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 你决定跳转到 <code>CrisisListComponent</code>，它的路由路径是'/'，但你不用显式的添加它。</p><p translation-origin=\"off\">You're navigating to the <code>CrisisListComponent</code>, whose route path is <code>/</code>, but you don't need to explicitly add the slash.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">考虑以下路由器链接，它将从应用的根目录导航到巨龙危机（Dragon Crisis）：</p><p translation-origin=\"off\">Consider the following router link that navigates from the root of the application down to the Dragon Crisis:</p>\n\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (Dragon-anchor)\" region=\"Dragon-anchor\">\n&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center', 1]\">Dragon Crisis&#x3C;/a>\n\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\"> 数组中的第一个条目标记出了父路由(<code>/crisis-center</code>)。</p><p translation-origin=\"off\">The first item in the array identifies the parent route (<code>/crisis-center</code>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">这个父路由没有参数。</p><p translation-origin=\"off\">There are no parameters for this parent route.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 数组中的第二个条目（'/:id'）用来标记出到指定危机的详情页的子路由。</p><p translation-origin=\"off\">The second item identifies the child route details about a particular crisis (<code>/:id</code>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 详细的子路由需要一个 <code>id</code> 路由参数。</p><p translation-origin=\"off\">The details child route requires an <code>id</code> route parameter.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 你把<em>巨龙危机</em>的 <code>id</code> 添加为该数组中的第二个条目（<code>1</code>）。</p><p translation-origin=\"off\">You added the <code>id</code> of the Dragon Crisis as the second item in the array (<code>1</code>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 最终生成的路径是 <code>/crisis-center/1</code>。</p><p translation-origin=\"off\">The resulting path is <code>/crisis-center/1</code>.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">你也可以把危机中心的路由单独重新定义为 <code>AppComponent</code> 的模板：</p><p translation-origin=\"off\">You could also redefine the <code>AppComponent</code> template with Crisis Center routes exclusively:</p>\n\n<code-example path=\"router/src/app/app.component.3.ts\" header=\"src/app/app.component.ts (template)\" region=\"template\">\ntemplate: `\n  &#x3C;h1 class=\"title\">Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n  &#x3C;nav>\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center']\">Crisis Center&#x3C;/a>\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center/1', { foo: 'foo' }]\">Dragon Crisis&#x3C;/a>\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center/2']\">Shark Crisis&#x3C;/a>\n  &#x3C;/nav>\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n`\n\n</code-example>\n<p translation-result=\"on\">总之，你可以用一级、两级或多级路由来写应用程序。\n链接参数数组提供了用来表示任意深度路由的链接参数数组以及任意合法的路由参数序列、必须的路由器参数以及可选的路由参数对象。</p><p translation-origin=\"off\">In summary, you can write applications with one, two or more levels of routing.\nThe link parameters array affords the flexibility to represent any routing depth and any legal sequence of route paths, (required) router parameters, and (optional) route parameter objects.</p>\n\n<a id=\"browser-url-styles\"></a>\n<a id=\"location-strategy\"></a>\n<h2 id=\"locationstrategy-and-browser-url-styles\" translation-result=\"on\"><code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> 和浏览器的网址样式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#locationstrategy-and-browser-url-styles\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"locationstrategy-and-browser-url-styles\"><code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> and browser URL styles<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#locationstrategy-and-browser-url-styles\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当路由器导航到一个新的组件视图时，它会用该视图的 URL 来更新浏览器的当前地址以及历史。\n严格来说，这个 URL 其实是本地的，浏览器不会把该 URL 发给服务器，并且不会重新加载此页面。</p><p translation-origin=\"off\">When the router navigates to a new component view, it updates the browser's location and history with a URL for that view.\nAs this is a strictly local URL the browser won't send this URL to the server and will not reload the page.</p>\n\n<p translation-result=\"on\">现代 HTML 5 浏览器支持<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\">history.pushState</a> API，\n这是一项可以改变浏览器的当前地址和历史，却又不会触发服务端页面请求的技术。\n路由器可以合成出一个“自然的”URL，它看起来和那些需要进行页面加载的 URL 没什么区别。</p><p translation-origin=\"off\">Modern HTML5 browsers support <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a>, a technique that changes a browser's location and history without triggering a server page request.\nThe router can compose a \"natural\" URL that is indistinguishable from one that would otherwise require a page load.</p>\n\n<p translation-result=\"on\">下面是危机中心的 URL 在“HTML 5 pushState”风格下的样子：</p><p translation-origin=\"off\">Here's the Crisis Center URL in this \"HTML5 pushState\" style:</p>\n\n<code-example format=\"nocode\">\n  localhost:3002/crisis-center/\n\n</code-example>\n<p translation-result=\"on\">老旧的浏览器在当前地址的 URL 变化时总会往服务器发送页面请求……唯一的例外规则是：当这些变化位于“#”（被称为“hash”）后面时不会发送。通过把应用内的路由 URL 拼接在 <code>#</code> 之后，路由器可以获得这条“例外规则”带来的优点。下面是到<em>危机中心</em>路由的“hash URL”：</p><p translation-origin=\"off\">Older browsers send page requests to the server when the location URL changes unless the change occurs after a \"#\" (called the \"hash\").\nRouters can take advantage of this exception by composing in-application route URLs with hashes.\nHere's a \"hash URL\" that routes to the Crisis Center.</p>\n\n<code-example format=\"nocode\">\n  localhost:3002/src/#/crisis-center/\n\n</code-example>\n<p translation-result=\"on\">路由器通过两种 <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> 提供者来支持所有这些风格：</p><p translation-origin=\"off\">The router supports both styles with two <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> providers:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/common/PathLocationStrategy\" class=\"code-anchor\">PathLocationStrategy</a></code> - 默认的策略，支持“HTML 5 pushState”风格。</p><p translation-origin=\"off\"><code><a href=\"api/common/PathLocationStrategy\" class=\"code-anchor\">PathLocationStrategy</a></code>—the default \"HTML5 pushState\" style.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> - 支持“hash URL”风格。</p><p translation-origin=\"off\"><code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code>—the \"hash URL\" style.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\"><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 函数把 <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> 设置成了 <code><a href=\"api/common/PathLocationStrategy\" class=\"code-anchor\">PathLocationStrategy</a></code>，使其成为了默认策略。\n你还可以在启动过程中改写（override）它，来切换到 <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> 风格。</p><p translation-origin=\"off\">The <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> function sets the <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> to the <code><a href=\"api/common/PathLocationStrategy\" class=\"code-anchor\">PathLocationStrategy</a></code>, which makes it the default strategy.\nYou also have the option of switching to the <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> with an override during the bootstrapping process.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">关于提供程序和引导过程的更多信息，请参阅<a href=\"guide/dependency-injection#bootstrap\">依赖注入</a>。</p><p translation-origin=\"off\">For more information on providers and the bootstrap process, see <a href=\"guide/dependency-injection#bootstrap\">Dependency Injection</a>.</p>\n\n</div>\n<h2 id=\"choosing-a-routing-strategy\" translation-result=\"on\">选择路由策略<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#choosing-a-routing-strategy\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"choosing-a-routing-strategy\">Choosing a routing strategy<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#choosing-a-routing-strategy\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你必须在开发项目的早期就选择一种路由策略，因为一旦该应用进入了生产阶段，你网站的访问者就会使用并依赖应用的这些 URL 引用。</p><p translation-origin=\"off\">You must choose a routing strategy early in the development of you project because once the application is in production, visitors to your site use and depend on application URL references.</p>\n\n<p translation-result=\"on\">几乎所有的 Angular 项目都会使用默认的 HTML 5 风格。它生成的 URL 更易于被用户理解，它也为将来做<strong>服务端渲染</strong>预留了空间。</p><p translation-origin=\"off\">Almost all Angular projects should use the default HTML5 style.\nIt produces URLs that are easier for users to understand and it preserves the option to do server-side rendering.</p>\n\n<p translation-result=\"on\">在服务器端渲染指定的页面，是一项可以在该应用首次加载时大幅提升响应速度的技术。那些原本需要十秒甚至更长时间加载的应用，可以预先在服务端渲染好，并在少于一秒的时间内完整渲染在用户的设备上。</p><p translation-origin=\"off\">Rendering critical pages on the server is a technique that can greatly improve perceived responsiveness when the app first loads.\nAn app that would otherwise take ten or more seconds to start could be rendered on the server and delivered to the user's device in less than a second.</p>\n\n<p translation-result=\"on\">只有当应用的 URL 看起来像是标准的 Web URL，中间没有 hash（#）时，这个选项才能生效。</p><p translation-origin=\"off\">This option is only available if application URLs look like normal web URLs without hashes (#) in the middle.</p>\n\n<h2 id=\"base-href-1\"><code>&#x3C;base href></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#base-href-1\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\">路由器使用浏览器的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a> API 进行导航。借助 <code>pushState</code> 你自定义应用中的 URL 路径 <code>localhost:4200/crisis-center</code>，应用内的 URL 和服务器的 URL 没有区别。</p><p translation-origin=\"off\">The router uses the browser's <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a> for navigation.\n<code>pushState</code> allows you to customize in-app URL paths; for example, <code>localhost:4200/crisis-center</code>.\nThe in-app URLs can be indistinguishable from server URLs.</p>\n\n<p translation-result=\"on\">现代的 HTML5 浏览器都支持 <code>pushState</code>，这也就是为什么很多人把这种 URL 形式称为 \"HTML 5\" 风格的 URL。</p><p translation-origin=\"off\">Modern HTML5 browsers were the first to support <code>pushState</code> which is why many people refer to these URLs as \"HTML5 style\" URLs.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">路由器默认使用 HTML5 风格的导航。\n在 <a href=\"guide/router#browser-url-styles\">LocationStrategy 与浏览器 URL 风格</a>部分，你可以了解为何推荐使用 HTML5 风格的 URL，如何调整其行为，以及必要时如何切换到老式的 hash（#）风格。</p><p translation-origin=\"off\">HTML5 style navigation is the router default.\nIn the <a href=\"guide/router#browser-url-styles\">LocationStrategy and browser URL styles</a> section, learn why HTML5 style is preferable, how to adjust its behavior, and how to switch to the older hash (#) style, if necessary.</p>\n\n</div>\n<p translation-result=\"on\">你必须在应用的 <code>index.html</code> 中<strong>添加一个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\" title=\"base href\">&#x3C;base href> 元素</a></strong>才能让 <code>pushState</code> 路由正常工作。\n浏览器要用 <code>&#x3C;base href></code> 的值为引用 CSS、脚本和图片文件时使用的<em>相对</em> URL 添加前缀。</p><p translation-origin=\"off\">You must add a <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\" title=\"base href\">&#x3C;base href> element</a> to the app's <code>index.html</code> for <code>pushState</code> routing to work.\nThe browser uses the <code>&#x3C;base href></code> value to prefix relative URLs when referencing CSS files, scripts, and images.</p>\n\n<p translation-result=\"on\">请把 <code>&#x3C;base></code> 元素添加在 <code>&#x3C;head></code> 标签的紧后面。如果应用的根目录是 <code>app</code> 目录，那么就可以像这个应用程序一样，设置 <strong><code>index.html</code></strong> 中的 <code>href</code> 值。代码如下。</p><p translation-origin=\"off\">Add the <code>&#x3C;base></code> element just after the  <code>&#x3C;head></code> tag.\nIf the <code>app</code> folder is the application root, as it is for this application,\nset the <code>href</code> value in <code>index.html</code> as shown here.</p>\n\n<code-example path=\"router/src/index.html\" header=\"src/index.html (base-href)\" region=\"base-href\">\n&#x3C;base href=\"/\">\n\n</code-example>\n<h3 id=\"html5-urls-and-the--base-href\" translation-result=\"on\">HTML5 网址和 <code>&#x3C;base href></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#html5-urls-and-the--base-href\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"html5-urls-and-the--base-href\">HTML5 URLs and the  <code>&#x3C;base href></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#html5-urls-and-the--base-href\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">后面的指南中会引用 URL 的不同部分。下图是这些部分所指内容的梗概：</p><p translation-origin=\"off\">The guidelines that follow will refer to different parts of a URL. This diagram outlines what those parts refer to:</p>\n\n<code-example>\nfoo://example.com:8042/over/there?name=ferret#nose\n\\_/   \\______________/\\_________/ \\_________/ \\__/\n |           |            |            |        |\nscheme    authority      path        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>   fragment\n</code-example>\n<p translation-result=\"on\">由于路由器默认使用 “<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" target=\"_blank\" title=\"Browser history push-state\">HTML 5 pushState</a>” 风格，所以你<em>必须</em>用一个 <code>&#x3C;base href></code> 来配置该策略（Strategy）。</p><p translation-origin=\"off\">While the router uses the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"Browser history push-state\">HTML5 pushState</a> style by default, you must configure that strategy with a <code>&#x3C;base href></code>.</p>\n\n<p translation-result=\"on\">配置该策略的首选方式是往 <code>index.html</code> 的 <code>&#x3C;head></code> 中添加一个<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\">&#x3C;base href> element</a>标签。</p><p translation-origin=\"off\">The preferred way to configure the strategy is to add a <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\" title=\"base href\">&#x3C;base href> element</a> tag in the <code>&#x3C;head></code> of the <code>index.html</code>.</p>\n\n<code-example path=\"router/src/index.html\" header=\"src/index.html (base-href)\" region=\"base-href\">\n&#x3C;base href=\"/\">\n\n</code-example>\n<p translation-result=\"on\">如果没有该标记，浏览器就可能无法在“深度链接”进入应用时加载资源（图片，CSS，脚本）。</p><p translation-origin=\"off\">Without that tag, the browser may not be able to load resources\n(images, CSS, scripts) when \"deep linking\" into the app.</p>\n\n<p translation-result=\"on\">有些开发人员可能无法添加 <code>&#x3C;base></code> 元素，这可能是因为它们没有访问 <code>&#x3C;head></code> 或 <code>index.html</code> 的权限。</p><p translation-origin=\"off\">Some developers may not be able to add the <code>&#x3C;base></code> element, perhaps because they don't have access to <code>&#x3C;head></code> or the <code>index.html</code>.</p>\n\n<p translation-result=\"on\">它们仍然可以使用 HTML 5 格式的 URL，但要采取如下步骤进行补救：</p><p translation-origin=\"off\">Those developers may still use HTML5 URLs by taking the following two steps:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">用适当的[APP_BASE_HREF][]值提供（provide）路由器。</p><p translation-origin=\"off\">Provide the router with an appropriate <code><a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a></code> value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">对所有 Web 资源（CSS、图片、脚本和模板 HTML 文件）使用根 URL（高优先度 URL）。</p><p translation-origin=\"off\">Use root URLs (URLs with an <code>authority</code>) for all web resources: CSS, images, scripts, and template HTML files.</p>\n\n</li>\n</ol>\n<ul>\n<li>\n<p translation-result=\"on\"> <code>&#x3C;base href></code> 的 <code>path</code> 应该用 \"/\" 结尾，浏览器会忽略 <code>path</code> 中最右边的 \"/\" 后面的字符。</p><p translation-origin=\"off\">The <code>&#x3C;base href></code> <code>path</code> should end with a \"/\", as browsers ignore characters in the <code>path</code> that follow the right-most \"/\".</p>\n\n</li>\n<li>\n<p translation-result=\"on\">   如果 <code>&#x3C;base href></code> 包含 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 部分，则只有页内链接的 <code>path</code> 部分为空并且没有 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 时，才会使用这里的 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code>。\n这意味着 <code>&#x3C;base href></code> 中的 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 部分只有在使用 <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> 策略时才有用。</p><p translation-origin=\"off\">If the <code>&#x3C;base href></code> includes a <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> part, the <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> is only used if the <code>path</code> of a link in the page is empty and has no <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code>.\nThis means that a <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> in the <code>&#x3C;base href></code> is only included when using <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 如果页内链接是根 URL（高优先度 URL），则 <code>&#x3C;base href></code> 不会使用。在这种方式下，<code><a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a></code> 的优先度将会导致所有由 Angular 创建的链接忽略 <code>&#x3C;base href></code>。</p><p translation-origin=\"off\">If a link in the page is a root URL (has an <code>authority</code>), the <code>&#x3C;base href></code> is not used. In this way, an <code><a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a></code> with an authority will cause all links created by Angular to ignore the <code>&#x3C;base href></code> value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <code>&#x3C;base href></code> 中的片段（#后面的部分）<em>永远不会</em>被使用。</p><p translation-origin=\"off\">A fragment in the <code>&#x3C;base href></code> is <em>never</em> persisted.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">   对所有 Web 资源使用绝对地址：CSS、图片、脚本、模板 HTML。</p><p translation-origin=\"off\">For more complete information on how <code>&#x3C;base href></code> is used to construct target URIs, see the <a href=\"https://tools.ietf.org/html/rfc3986#section-5.2.2\">RFC</a> section on transforming references.</p>\n\n<a id=\"hashlocationstrategy\"></a>\n<h3 id=\"hashlocationstrategy\"><code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#hashlocationstrategy\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">你可以在根模块的 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 的第二个参数中传入一个带有 <code>useHash: true</code> 的对象，以回到基于 <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> 的传统方式。</p><p translation-origin=\"off\">You can use <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> by providing the <code>useHash: true</code> in an object as the second argument of the <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> in the <code>AppModule</code>.</p>\n\n<code-example path=\"router/src/app/app.module.6.ts\" header=\"src/app/app.module.ts (hash URL strategy)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\n\nimport { AppComponent } from './app.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst routes: <a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a> = [\n\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    RouterModule.forRoot(routes, { useHash: true })  // .../#/crisis-center/\n  ],\n  declarations: [\n    AppComponent,\n    PageNotFoundComponent\n  ],\n  providers: [\n\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<h2 id=\"router-reference\" translation-result=\"on\">路由器参考手册<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-reference\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"router-reference\">Router Reference<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-reference\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">下面的部分重点介绍了一些路由器的核心概念。</p><p translation-origin=\"off\">The following sections highlight some core router concepts.</p>\n\n<a id=\"basics-router-imports\"></a>\n<h3 id=\"router-imports\" translation-result=\"on\">路由器导入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-imports\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"router-imports\">Router imports<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-imports\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 的 Router 是一个可选服务，它为指定的 URL 提供特定的组件视图。它不是 Angular 核心的一部分，因此它位于自己的包 <code>@angular/router</code> 中。</p><p translation-origin=\"off\">The Angular Router is an optional service that presents a particular component view for a given URL.\nIt is not part of the Angular core and thus is in its own library package, <code>@angular/router</code>.</p>\n\n<p translation-result=\"on\">从任何其它的 Angular 包中导入你需要的东西。</p><p translation-origin=\"off\">Import what you need from it as you would from any other Angular package.</p>\n\n<code-example path=\"router/src/app/app.module.1.ts\" header=\"src/app/app.module.ts (import)\" region=\"import-router\">\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">关于浏览器 URL 风格的更多信息，请参阅 <a href=\"guide/router#browser-url-styles\"><code>LocationStrategy</code> 和浏览器 URL 风格</a>。</p><p translation-origin=\"off\">For more on browser URL styles, see <a href=\"guide/router#browser-url-styles\"><code>LocationStrategy</code> and browser URL styles</a>.</p>\n\n</div>\n<a id=\"basics-config\"></a>\n<h3 id=\"configuration\" translation-result=\"on\">配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#configuration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"configuration\">Configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#configuration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">带路由的 Angular 应用中有一个 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服务的单例实例。当浏览器的 URL 发生变化时，该路由器会查找相应的 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>，以便根据它确定要显示的组件。</p><p translation-origin=\"off\">A routed Angular application has one singleton instance of the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> service.\nWhen the browser's URL changes, that router looks for a corresponding <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> from which it can determine the component to display.</p>\n\n<p translation-result=\"on\">在配置之前，路由器没有任何路由。下面的例子创建了五个路由定义，通过 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 方法配置路由器，并把结果添加到 <code>AppModule</code> 的 <code>imports</code> 数组中。</p><p translation-origin=\"off\">A router has no routes until you configure it.\nThe following example creates five route definitions, configures the router via the <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> method, and adds the result to the <code>AppModule</code>'s <code>imports</code> array.</p>\n\n<code-example path=\"router/src/app/app.module.0.ts\" header=\"src/app/app.module.ts (excerpt)\">\nconst appRoutes: <a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'hero/:id',      component: HeroDetailComponent },\n  {\n    path: 'heroes',\n    component: HeroListComponent,\n    data: { title: 'Heroes List' }\n  },\n  { path: '',\n    redirectTo: '/heroes',\n    pathMatch: 'full'\n  },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &#x3C;-- debugging purposes only\n    )\n    // other imports here\n  ],\n  ...\n})\nexport class AppModule { }\n\n</code-example>\n<a id=\"example-config\"></a>\n<p translation-result=\"on\"><code>appRoutes</code> 路由数组描述了如何导航。把它传给模块的 <code>imports</code> 数组中的 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 方法来配置路由器。</p><p translation-origin=\"off\">The <code>appRoutes</code> array of routes describes how to navigate.\nPass it to the <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> method in the module <code>imports</code> to configure the router.</p>\n\n<p translation-result=\"on\">每个 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 都会把一个 URL <code>path</code> 映射到一个组件。路径中没有前导斜杠。路由器会为你解析并构建最终的 URL，这样你就可以在应用视图中导航时使用相对路径和绝对路径了。</p><p translation-origin=\"off\">Each <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> maps a URL <code>path</code> to a component.\nThere are no leading slashes in the path.\nThe router parses and builds the final URL for you, which allows you to use both relative and absolute paths when navigating between application views.</p>\n\n<p translation-result=\"on\">第二个路由中的 <code>:id</code> 是路由参数的令牌。在像 <code>/hero/42</code> 这样的 URL 中，“42”是 <code>id</code> 参数的值。相应的 <code>HeroDetailComponent</code> 用这个值来查找并显示 <code>id</code> 为 42 的英雄。</p><p translation-origin=\"off\">The <code>:id</code> in the second route is a token for a route parameter.\nIn a URL such as <code>/hero/42</code>, \"42\" is the value of the <code>id</code> parameter.\nThe corresponding <code>HeroDetailComponent</code> uses that value to find and present the hero whose <code>id</code> is 42.</p>\n\n<p translation-result=\"on\">第三个路由中的 <code>data</code> 属性是存放与该特定路由关联的任意数据的地方。每个激活的路由都可以访问 <code>data</code> 属性。可以用它来存储页面标题，面包屑文本和其它只读静态数据等项目。你可以尝试使用<a href=\"guide/router-tutorial-toh#resolve-guard\">解析器守卫</a>来检索动态数据。</p><p translation-origin=\"off\">The <code>data</code> property in the third route is a place to store arbitrary data associated with\nthis specific route.\nThe data property is accessible within each activated route. Use it to store items such as page titles, breadcrumb text, and other read-only, static data.\nYou can use the <a href=\"guide/router-tutorial-toh#resolve-guard\">resolve guard</a> to retrieve dynamic data.</p>\n\n<p translation-result=\"on\">第四个路由中的空路径表示该应用的默认路径 - 当 URL 中的路径为空时通常要去的地方，就像它在刚进来时一样。这个默认路由重定向到了 <code>/heroes</code> 这个 URL 的路由，因此会显示 <code>HeroesListComponent</code>。</p><p translation-origin=\"off\">The empty path in the fourth route represents the default path for the application—the place to go when the path in the URL is empty, as it typically is at the start.\nThis default route redirects to the route for the <code>/heroes</code> URL and, therefore, displays the <code>HeroesListComponent</code>.</p>\n\n<p translation-result=\"on\">如果你需要查看导航生命周期中发生了什么事件，可以把 <code>enableTracing</code> 选项作为路由器默认配置的一部分。这会把每个导航生命周期中发生的每个路由器事件都输出到浏览器控制台中。<code>enableTracing</code> 只会用于调试目的。你可以把 <code>enableTracing: true</code> 选项作为第二个参数传给 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 方法。</p><p translation-origin=\"off\">If you need to see what events are happening during the navigation lifecycle, there is the <code>enableTracing</code> option as part of the router's default configuration.\nThis outputs each router event that took place during each navigation lifecycle to the browser console.\nUse <code>enableTracing</code> only for debugging purposes.\nYou set the <code>enableTracing: true</code> option in the object passed as the second argument to the <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> method.</p>\n\n<a id=\"basics-router-outlet\"></a>\n<h3 id=\"router-outlet\" translation-result=\"on\">路由出口<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-outlet\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"router-outlet\">Router outlet<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-outlet\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 是一个来自路由器库的指令，虽然它的用法像组件一样。它充当占位符，用于在模板中标记出路由器应该显示把该组件显示在那个出口的位置。</p><p translation-origin=\"off\">The <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> is a directive from the router library that is used like a component.\nIt acts as a placeholder that marks the spot in the template where the router should\ndisplay the components for that outlet.</p>\n\n<code-example language=\"html\">\n  &#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n  &#x3C;!-- Routed components go here -->\n\n</code-example>\n<p translation-result=\"on\">对于上面的配置，当这个应用的浏览器 URL 变为 <code>/heroes</code> 时，路由器就会把这个 URL 与路由路径 <code>/heroes</code> 匹配，并把 <code>HeroListComponent</code> 作为兄弟元素显示在宿主组件模板中的 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 下方。</p><p translation-origin=\"off\">Given the configuration above, when the browser URL for this application becomes <code>/heroes</code>, the router matches that URL to the route path <code>/heroes</code> and displays the <code>HeroListComponent</code> as a sibling element to the <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> that you've placed in the host component's template.</p>\n\n<a id=\"basics-router-links\"></a>\n<a id=\"router-link\"></a>\n<h3 id=\"router-links\" translation-result=\"on\">路由链接<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-links\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"router-links\">Router links<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-links\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要想通过某些用户操作（比如单击一下 a 标签）进行导航，请使用 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>。</p><p translation-origin=\"off\">To navigate as a result of some user action such as the click of an anchor tag, use <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>.</p>\n\n<p translation-result=\"on\">考虑下面的模板：</p><p translation-origin=\"off\">Consider the following template:</p>\n\n<code-example path=\"router/src/app/app.component.1.html\" header=\"src/app/app.component.html\">\n&#x3C;h1>Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&#x3C;/h1>\n&#x3C;nav>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/a>\n  &#x3C;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/a>\n&#x3C;/nav>\n&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>\n\n</code-example>\n<p translation-result=\"on\">a 标签上的 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令让路由器可以控制这些元素。导航路径是固定的，所以你可以给 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 赋值一个字符串（“一次性”绑定）。</p><p translation-origin=\"off\">The <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> directives on the anchor tags give the router control over those elements.\nThe navigation paths are fixed, so you can assign a string to the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> (a \"one-time\" binding).</p>\n\n<p translation-result=\"on\">如果导航路径更加动态，你可以给它绑定到一个模板表达式，该表达式要返回一个<a href=\"guide/router#link-parameters-array\">链接参数数组</a>。路由器会把该数组解析成一个完整的 URL。</p><p translation-origin=\"off\">Had the navigation path been more dynamic, you could have bound to a template expression that returned an array of route link parameters; that is, the <a href=\"guide/router#link-parameters-array\">link parameters array</a>.\nThe router resolves that array into a complete URL.</p>\n\n<a id=\"router-link-active\"></a>\n<h3 id=\"active-router-links\" translation-result=\"on\">活动路由链路<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#active-router-links\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"active-router-links\">Active router links<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#active-router-links\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code> 指令会根据当前的 <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code> 切换活动 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 上所绑定的 CSS 类。</p><p translation-origin=\"off\">The <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code> directive toggles CSS classes for active <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> bindings based on the current <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code>.</p>\n\n<p translation-result=\"on\">在每个 a 标签上，你会看到一个到 <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code> 指令的<a href=\"guide/property-binding\">属性绑定</a>，就像 <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"...\"</code>。</p><p translation-origin=\"off\">On each anchor tag, you see a <a href=\"guide/property-binding\">property binding</a> to the <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code> directive that looks like <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"...\"</code>.</p>\n\n<p translation-result=\"on\">等号 <code>=</code> 右侧的模板表达式，包含一个以空格分隔的 CSS 类字符串，当这个链接处于活动状态时，路由器就会加上这些字符串（并在非活动状态时删除）。你可以把 <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code> 指令设置成一串类的字符串，比如 <code>[<a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>]=\"'active fluffy'\"</code>，也可以把它绑定到一个返回这样一个字符串的组件属性上。</p><p translation-origin=\"off\">The template expression to the right of the equal sign, <code>=</code>, contains a space-delimited string of CSS classes that the Router adds when this link is active (and removes when the link is inactive).\nYou set the <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code> directive to a string of classes such as <code>[<a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>]=\"'active fluffy'\"</code> or bind it to a component property that returns such a string.</p>\n\n<p translation-result=\"on\">活动路由链接会级联到路由树的每个级别，这样父路由和子路由链接就可以同时处于活动状态。要覆盖这种行为，你可以用 <code>{ exact: true }</code> 表达式绑定到 <code>[routerLinkActiveOptions]</code> 输入绑定。使用 <code>{ exact: true }</code> 之后，给定的 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 只有在 URL 与当前 URL 完全匹配时才会激活。</p><p translation-origin=\"off\">Active route links cascade down through each level of the route tree, so parent and child router links can be active at the same time.\nTo override this behavior, you can bind to the <code>[routerLinkActiveOptions]</code> input binding with the <code>{ exact: true }</code> expression. By using <code>{ exact: true }</code>, a given <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> will only be active if its URL is an exact match to the current URL.</p>\n\n<a id=\"basics-router-state\"></a>\n<h3 id=\"router-state\" translation-result=\"on\">路由器状态<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-state\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"router-state\">Router state<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-state\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">每个成功的导航生命周期结束后，路由器都会构建一个 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 对象树，它构成了路由器的当前状态。你可以从任何地方使用应用的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服务和 <code>routerState</code> 属性来访问当前的 <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code>。</p><p translation-origin=\"off\">After the end of each successful navigation lifecycle, the router builds a tree of <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> objects that make up the current state of the router. You can access the current <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code> from anywhere in the application using the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> service and the <code>routerState</code> property.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code> 中的每个 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 都提供了向上或向下遍历路由树的方法，用于从父路由、子路由和兄弟路由中获取信息。</p><p translation-origin=\"off\">Each <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> in the <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code> provides methods to traverse up and down the route tree to get information from parent, child and sibling routes.</p>\n\n<a id=\"activated-route\"></a>\n<h3 id=\"activated-route\" translation-result=\"on\">激活路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#activated-route\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"activated-route\">Activated route<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#activated-route\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">路由的路径和参数可以通过注入名为 <a href=\"api/router/ActivatedRoute\">ActivatedRoute</a> 的路由服务获得。它提供了大量有用的信息，包括：</p><p translation-origin=\"off\">The route path and parameters are available through an injected router service called the <a href=\"api/router/ActivatedRoute\">ActivatedRoute</a>.\nIt has a great deal of useful information including:</p>\n\n<table>\n  <tbody><tr>\n    <th>\n<p translation-result=\"on\">      属性</p><p translation-origin=\"off\">      Property</p>\n\n    </th>\n<th>\n<p translation-result=\"on\">  说明</p><p translation-origin=\"off\">  Description</p>\n\n</th>\n  </tr>\n  <tr>\n    <td>\n      <code>url</code>\n    </td>\n    <td>\n<p translation-result=\"on\">一个路由路径的 <code>Observable</code>，是一个由路由路径的各个部分组成的字符串数组。</p><p translation-origin=\"off\">An <code>Observable</code> of the route path(s), represented as an array of strings for each part of the route path.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code>data</code>\n    </td>\n    <td>\n<p translation-result=\"on\">包含提供给当前路由的 <code>data</code> 对象的 <code>Observable</code>。\n也包含任何由<a href=\"guide/router-tutorial-toh#resolve-guard\">解析守卫</a>解析出的值。</p><p translation-origin=\"off\">An <code>Observable</code> that contains the <code>data</code> object provided for the route.\nAlso contains any resolved values from the <a href=\"guide/router-tutorial-toh#resolve-guard\">resolve guard</a>.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code>paramMap</code>\n    </td>\n    <td>\n<p translation-result=\"on\">一个包含该路由的必要参数和<a href=\"guide/router-tutorial-toh#optional-route-parameters\">可选参数</a> <a href=\"api/router/ParamMap\">map</a> 的 <code>Observable</code>。\n这个 map 支持从同一个参数中获得单个或多个值。</p><p translation-origin=\"off\">An <code>Observable</code> that contains a <a href=\"api/router/ParamMap\">map</a> of the required and <a href=\"guide/router-tutorial-toh#optional-route-parameters\">optional parameters</a> specific to the route.\nThe map supports retrieving single and multiple values from the same parameter.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code>queryParamMap</code>\n    </td>\n    <td>\n<p translation-result=\"on\">一个包含适用于所有路由的<a href=\"guide/router-tutorial-toh#query-parameters\">查询参数</a> <a href=\"api/router/ParamMap\">map</a> 的 <code>Observable</code>。\n这个 map 支持从同一个查询参数中获得单个或多个值。</p><p translation-origin=\"off\">An <code>Observable</code> that contains a <a href=\"api/router/ParamMap\">map</a> of the <a href=\"guide/router-tutorial-toh#query-parameters\">query parameters</a> available to all routes.\nThe map supports retrieving single and multiple values from the query parameter.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code>fragment</code>\n    </td>\n    <td>\n<p translation-result=\"on\">一个适用于所有路由的 URL <a href=\"guide/router-tutorial-toh#fragment\">片段</a>的 <code>Observable</code>。</p><p translation-origin=\"off\">An <code>Observable</code> of the URL <a href=\"guide/router-tutorial-toh#fragment\">fragment</a> available to all routes.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code>outlet</code>\n    </td>\n    <td>\n<p translation-result=\"on\">用来渲染该路由的 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 的名字。\n对于无名出口，这个出口的名字是 <code>primary</code>。</p><p translation-origin=\"off\">The name of the <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> used to render the route.\nFor an unnamed outlet, the outlet name is primary.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code>routeConfig</code>\n    </td>\n    <td>\n<p translation-result=\"on\">包含原始路径的那个路由的配置信息。</p><p translation-origin=\"off\">The route configuration used for the route that contains the origin path.</p>\n\n</td>\n  </tr>\n<tr>\n<td>\n  <code>parent</code>\n</td>\n<td>\n<p translation-result=\"on\">当该路由是<a href=\"guide/router-tutorial-toh#child-routing-component\">子路由</a>时，表示该路由的父级 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>。</p><p translation-origin=\"off\">The route's parent <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> when this route is a <a href=\"guide/router-tutorial-toh#child-routing-component\">child route</a>.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code>firstChild</code>\n    </td>\n    <td>\n<p translation-result=\"on\">包含该路由的子路由列表中的第一个 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>。</p><p translation-origin=\"off\">Contains the first <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> in the list of this route's child routes.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code>children</code>\n    </td>\n    <td>\n<p translation-result=\"on\">包含当前路由下所有激活的<a href=\"guide/router-tutorial-toh#child-routing-component\">子路由</a>。</p><p translation-origin=\"off\">Contains all the <a href=\"guide/router-tutorial-toh#child-routing-component\">child routes</a> activated under the current route.</p>\n\n</td>\n  </tr>\n</tbody></table>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">还有两个较旧的属性，但更推荐使用它们的替代品，因为它们可能会在以后的 Angular 版本中弃用。</p><p translation-origin=\"off\">Two older properties are still available, however, their replacements are preferable as they may be deprecated in a future Angular version.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>params</code> ：一个 <code>Observable</code>，它包含专属于该路由的必要参数和<a href=\"guide/router-tutorial-toh#optional-route-parameters\">可选参数</a>。请改用 <code>paramMap</code>。</p><p translation-origin=\"off\"><code>params</code>: An <code>Observable</code> that contains the required and <a href=\"guide/router-tutorial-toh#optional-route-parameters\">optional parameters</a> specific to the route. Use <code>paramMap</code> instead.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>queryParams</code>：一个包含可用于所有路由的<a href=\"guide/router-tutorial-toh#query-parameters\">查询参数</a>的 <code>Observable</code>。请改用 <code>queryParamMap</code>。</p><p translation-origin=\"off\"><code>queryParams</code>: An <code>Observable</code> that contains the <a href=\"guide/router-tutorial-toh#query-parameters\">query parameters</a> available to all routes.\nUse <code>queryParamMap</code> instead.</p>\n\n</li>\n</ul>\n</div>\n<h3 id=\"router-events\" translation-result=\"on\">路由器事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-events\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"router-events\">Router events<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-events\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 在每次导航过程中都会通过 <code><a href=\"api/router/Router#events\" class=\"code-anchor\">Router.events</a></code> 属性发出导航事件。这些事件的范围贯穿从导航开始和结束之间的多个时间点。导航事件的完整列表如下表所示。</p><p translation-origin=\"off\">During each navigation, the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> emits navigation events through the <code><a href=\"api/router/Router#events\" class=\"code-anchor\">Router.events</a></code> property.\nThese events range from when the navigation starts and ends to many points in between. The full list of navigation events is displayed in the table below.</p>\n\n<table>\n  <tbody><tr>\n    <th>\n<p translation-result=\"on\">      路由事件</p><p translation-origin=\"off\">      Router Event</p>\n\n    </th>\n<th>\n<p translation-result=\"on\">  说明</p><p translation-origin=\"off\">  Description</p>\n\n</th>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  导航开始时触发的<a href=\"api/router/NavigationStart\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/NavigationStart\">event</a> triggered when navigation starts.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RouteConfigLoadStart\" class=\"code-anchor\">RouteConfigLoadStart</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  在 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> <a href=\"guide/router-tutorial-toh#asynchronous-routing\">惰性加载</a>路由配置之前触发的<a href=\"api/router/RouteConfigLoadStart\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/RouteConfigLoadStart\">event</a> triggered before the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>\n<a href=\"guide/router-tutorial-toh#asynchronous-routing\">lazy loads</a> a route configuration.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RouteConfigLoadEnd\" class=\"code-anchor\">RouteConfigLoadEnd</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  在某个路由已经惰性加载完毕时触发的<a href=\"api/router/RouteConfigLoadEnd\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/RouteConfigLoadEnd\">event</a> triggered after a route has been lazy loaded.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/RoutesRecognized\" class=\"code-anchor\">RoutesRecognized</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  当路由器解析了 URL，而且路由已经识别完毕时触发的<a href=\"api/router/RoutesRecognized\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/RoutesRecognized\">event</a> triggered when the Router parses the URL and the routes are recognized.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/GuardsCheckStart\" class=\"code-anchor\">GuardsCheckStart</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  当路由器开始进入路由守卫阶段时触发的<a href=\"api/router/GuardsCheckStart\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/GuardsCheckStart\">event</a> triggered when the Router begins the Guards phase of routing.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ChildActivationStart\" class=\"code-anchor\">ChildActivationStart</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  当路由器开始激活某路由的子路由时触发的<a href=\"api/router/ChildActivationStart\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/ChildActivationStart\">event</a> triggered when the Router begins activating a route's children.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ActivationStart\" class=\"code-anchor\">ActivationStart</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  当路由器开始激活某个路由时触发的<a href=\"api/router/ActivationStart\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/ActivationStart\">event</a> triggered when the Router begins activating a route.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/GuardsCheckEnd\" class=\"code-anchor\">GuardsCheckEnd</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  当路由器成功结束了路由守卫阶段时触发的<a href=\"api/router/GuardsCheckEnd\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/GuardsCheckEnd\">event</a> triggered when the Router finishes the Guards phase of routing successfully.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ResolveStart\" class=\"code-anchor\">ResolveStart</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  当路由器开始路由解析阶段时触发的<a href=\"api/router/ResolveStart\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/ResolveStart\">event</a> triggered when the Router begins the Resolve phase of routing.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ResolveEnd\" class=\"code-anchor\">ResolveEnd</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  当路由器的路由解析阶段成功完成时触发的<a href=\"api/router/ResolveEnd\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/ResolveEnd\">event</a> triggered when the Router finishes the Resolve phase of routing successfuly.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ChildActivationEnd\" class=\"code-anchor\">ChildActivationEnd</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  当路由器成功激活某路由的子路由时触发的<a href=\"api/router/ChildActivationEnd\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/ChildActivationEnd\">event</a> triggered when the Router finishes activating a route's children.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/ActivationEnd\" class=\"code-anchor\">ActivationEnd</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  当路由器成功激活了某个路由时触发的<a href=\"api/router/ActivationStart\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/ActivationStart\">event</a> triggered when the Router finishes activating a route.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/NavigationEnd\" class=\"code-anchor\">NavigationEnd</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  当导航成功结束时触发的<a href=\"api/router/NavigationEnd\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/NavigationEnd\">event</a> triggered when navigation ends successfully.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/NavigationCancel\" class=\"code-anchor\">NavigationCancel</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  当导航被取消时触发的<a href=\"api/router/NavigationCancel\">事件</a>。\n这可能在导航期间某个<a href=\"guide/router-tutorial-toh#guards\">路由守卫</a>返回了 false 或返回了 <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> 以进行重定向时发生。</p><p translation-origin=\"off\">  An <a href=\"api/router/NavigationCancel\">event</a> triggered when navigation is canceled.\nThis can happen when a <a href=\"guide/router-tutorial-toh#guards\">Route Guard</a> returns false during navigation,\nor redirects by returning a <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code>.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/NavigationError\" class=\"code-anchor\">NavigationError</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  当导航由于非预期的错误而失败时触发的<a href=\"api/router/NavigationError\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/NavigationError\">event</a> triggered when navigation fails due to an unexpected error.</p>\n\n</td>\n  </tr>\n  <tr>\n    <td>\n      <code><a href=\"api/router/Scroll\" class=\"code-anchor\">Scroll</a></code>\n    </td>\n    <td>\n<p translation-result=\"on\">  用来表示滚动的<a href=\"api/router/Scroll\">事件</a>。</p><p translation-origin=\"off\">  An <a href=\"api/router/Scroll\">event</a> that represents a scrolling event.</p>\n\n</td>\n  </tr>\n</tbody></table>\n<p translation-result=\"on\">当启用了 <code>enableTracing</code> 选项时，Angular 会把这些事件都记录到控制台。关于筛选路由器导航事件的范例，请参阅 <a href=\"guide/observables-in-angular\">Angular 中的 Observables</a> 一章的<a href=\"guide/observables-in-angular#router\">路由器部分</a>。</p><p translation-origin=\"off\">When you enable the <code>enableTracing</code> option, Angular logs these events to the console.\nFor an example of filtering router navigation events, see the <a href=\"guide/observables-in-angular#router\">router section</a> of the <a href=\"guide/observables-in-angular\">Observables in Angular</a> guide.</p>\n\n<h3 id=\"router-terminology\" translation-result=\"on\">路由器术语<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-terminology\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"router-terminology\">Router terminology<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#router-terminology\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">这里是一些关键的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 术语及其含义：</p><p translation-origin=\"off\">Here are the key <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> terms and their meanings:</p>\n\n<table>\n  <tbody><tr>\n<th>\n<p translation-result=\"on\">  路由器部件</p><p translation-origin=\"off\">  Router Part</p>\n\n</th>\n<th>\n<p translation-result=\"on\">  含义</p><p translation-origin=\"off\">  Meaning</p>\n\n</th>\n  </tr>\n  <tr>\n<td>\n  <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>\n</td>\n<td>\n<p translation-result=\"on\">  为活动 URL 显示应用中的组件。\n管理从一个组件到另一个的导航。</p><p translation-origin=\"off\">  Displays the application component for the active URL.\nManages navigation from one component to the next.</p>\n\n</td>\n  </tr>\n  <tr>\n<td>\n  <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>\n</td>\n<td>\n<p translation-result=\"on\">  一个单独的 NgModule，它提供了一些必要的服务提供者和一些用于在应用视图间导航的指令。</p><p translation-origin=\"off\">  A separate NgModule that provides the necessary service providers\nand directives for navigating through application views.</p>\n\n</td>\n  </tr>\n  <tr>\n<td>\n  <code><a href=\"api/router/Routes-0\" class=\"code-anchor\">Routes</a></code>\n</td>\n<td>\n<p translation-result=\"on\">  定义一个路由数组，每一个条目都会把一个 URL 路径映射到组件。</p><p translation-origin=\"off\">  Defines an array of Routes, each mapping a URL path to a component.</p>\n\n</td>\n  </tr>\n  <tr>\n<td>\n  <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>\n</td>\n<td>\n<p translation-result=\"on\">  定义路由器如何基于一个 URL 模式导航到某个组件。\n大部分路由都由一个路径和一个组件类组成。</p><p translation-origin=\"off\">  Defines how the router should navigate to a component based on a URL pattern.\nMost routes consist of a path and a component type.</p>\n\n</td>\n  </tr>\n  <tr>\n<td>\n  <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>\n</td>\n<td>\n<p translation-result=\"on\">  该指令 (<code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>) 用于指出路由器应该把视图显示在哪里。</p><p translation-origin=\"off\">  The directive (<code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>) that marks where the router displays a view.</p>\n\n</td>\n  </tr>\n  <tr>\n<td>\n  <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>\n</td>\n<td>\n<p translation-result=\"on\">  用于将可点击的 HTML 元素绑定到某个路由的指令。单击带有 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 指令且绑定到<i>字符串</i>或<i>链接参数数组</i>的元素，将触发导航。</p><p translation-origin=\"off\">  The directive for binding a clickable HTML element to a route. Clicking an element with a <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> directive that is bound to a <i>string</i> or a <i>link parameters array</i> triggers a navigation.</p>\n\n</td>\n  </tr>\n  <tr>\n<td>\n  <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code>\n</td>\n<td>\n<p translation-result=\"on\">  该指令会在元素上或元素内包含的相关 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 处于活动/非活动状态时，从 HTML 元素上添加/移除类。</p><p translation-origin=\"off\">  The directive for adding/removing classes from an HTML element when an associated <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> contained on or inside the element becomes active/inactive.</p>\n\n</td>\n  </tr>\n  <tr>\n<td>\n  <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>\n</td>\n<td>\n<p translation-result=\"on\">  一个提供给每个路由组件的服务，其中包含当前路由专属的信息，例如路由参数、静态数据、解析数据、全局查询参数和全局片段。</p><p translation-origin=\"off\">  A service that is provided to each route component that contains route specific information such as route parameters, static data, resolve data, global query params, and the global fragment.</p>\n\n</td>\n  </tr>\n  <tr>\n<td>\n  <code><a href=\"api/router/RouterState\" class=\"code-anchor\">RouterState</a></code>\n</td>\n<td>\n<p translation-result=\"on\">  路由器的当前状态，包括一棵当前激活路由的树以及遍历这棵路由树的便捷方法。</p><p translation-origin=\"off\">  The current state of the router including a tree of the currently activated routes together with convenience methods for traversing the route tree.</p>\n\n</td>\n  </tr>\n  <tr>\n<td>\n<p translation-result=\"on\">  <b><i>链接参数数组</i></b></p><p translation-origin=\"off\">  <b><i>Link parameters array</i></b></p>\n\n</td>\n<td>\n<p translation-result=\"on\">  一个由路由器将其解释为路由指南的数组。你可以将该数组绑定到 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 或将该数组作为参数传给 <code> Router.navigate</code> 方法。</p><p translation-origin=\"off\">  An array that the router interprets as a routing instruction.\nYou can bind that array to a <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> or pass the array as an argument to the <code>Router.navigate</code> method.</p>\n\n</td>\n  </tr>\n  <tr>\n<td>\n<p translation-result=\"on\">  <b><i>路由组件</i></b></p><p translation-origin=\"off\">  <b><i>Routing component</i></b></p>\n\n</td>\n<td>\n<p translation-result=\"on\">  一个带有 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 的 Angular 组件，可基于路由器的导航来显示视图。</p><p translation-origin=\"off\">  An Angular component with a <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> that displays views based on router navigations.</p>\n\n</td>\n  </tr>\n</tbody></table>\n\n  \n</div>\n\n\n<!-- links to this doc:\n - api/router\n - api/router/ActivatedRoute\n - api/router/NavigationBehaviorOptions\n - api/router/NavigationExtras\n - api/router/Route\n - api/router/Router\n - api/router/RouterEvent\n - api/router/RouterModule\n - api/router/RouterState\n - api/router/Routes-0\n - api/router/UrlCreationOptions\n - guide/ajs-quick-reference\n - guide/architecture\n - guide/architecture-next-steps\n - guide/browser-support\n - guide/built-in-directives\n - guide/deployment\n - guide/deprecations\n - guide/docs-style-guide\n - guide/example-apps-list\n - guide/glossary\n - guide/hierarchical-dependency-injection\n - guide/lazy-loading-ngmodules\n - guide/module-types\n - guide/npm-packages\n - guide/universal\n - guide/upgrade\n - guide/what-is-angular\n - start/start-routing\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/APP_BASE_HREF\n - api/common/HashLocationStrategy\n - api/common/LocationStrategy\n - api/common/PathLocationStrategy\n - api/core/Component\n - api/core/NgModule\n - api/forms/FormsModule\n - api/platform-browser/BrowserModule\n - api/router\n - api/router/ActivatedRoute\n - api/router/ActivatedRouteSnapshot\n - api/router/ActivationEnd\n - api/router/ActivationStart\n - api/router/CanActivate\n - api/router/CanActivateChild\n - api/router/CanDeactivate\n - api/router/CanLoad\n - api/router/ChildActivationEnd\n - api/router/ChildActivationStart\n - api/router/GuardsCheckEnd\n - api/router/GuardsCheckStart\n - api/router/NavigationCancel\n - api/router/NavigationEnd\n - api/router/NavigationError\n - api/router/NavigationExtras\n - api/router/NavigationStart\n - api/router/ParamMap\n - api/router/Resolve\n - api/router/ResolveEnd\n - api/router/ResolveStart\n - api/router/Route\n - api/router/Route#componentless-routes\n - api/router/RouteConfigLoadEnd\n - api/router/RouteConfigLoadStart\n - api/router/Router\n - api/router/Router#events\n - api/router/RouterLink\n - api/router/RouterLinkActive\n - api/router/RouterModule\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/RouterState\n - api/router/RouterStateSnapshot\n - api/router/Routes-0\n - api/router/RoutesRecognized\n - api/router/Scroll\n - api/router/UrlTree\n - cli\n - guide/architecture-components\n - guide/dependency-injection#bootstrap\n - guide/glossary#template\n - guide/glossary#view\n - guide/lazy-loading-ngmodules\n - guide/observables-in-angular\n - guide/observables-in-angular#router\n - guide/property-binding\n - guide/router#404-page-how-to\n - guide/router#accessing-query-parameters-and-fragments\n - guide/router#activated-route\n - guide/router#active-router-links\n - guide/router#adding-components-for-routing\n - guide/router#base-href\n - guide/router#base-href-1\n - guide/router#browser-url-styles\n - guide/router#choosing-a-routing-strategy\n - guide/router#configuration\n - guide/router#defining-a-basic-route\n - guide/router#displaying-a-404-page\n - guide/router#generate-an-app-with-routing-enabled\n - guide/router#getting-route-information\n - guide/router#hashlocationstrategy\n - guide/router#html5-urls-and-the--base-href\n - guide/router#importing-your-new-components\n - guide/router#in-app-navigation-routing-to-views\n - guide/router#lazy-loading\n - guide/router#link-parameters-array\n - guide/router#locationstrategy-and-browser-url-styles\n - guide/router#nesting-routes\n - guide/router#prerequisites\n - guide/router#preventing-unauthorized-access\n - guide/router#route-order\n - guide/router#router-events\n - guide/router#router-imports\n - guide/router#router-links\n - guide/router#router-outlet\n - guide/router#router-reference\n - guide/router#router-state\n - guide/router#router-terminology\n - guide/router#setting-up-redirects\n - guide/router#setting-up-wildcard-routes\n - guide/router#specifying-a-relative-route\n - guide/router#using-relative-paths\n - guide/router#wildcard-route-how-to\n - guide/router-tutorial-toh#a-crisis-center-with-child-routes\n - guide/router-tutorial-toh#asynchronous-routing\n - guide/router-tutorial-toh#child-routing-component\n - guide/router-tutorial-toh#fragment\n - guide/router-tutorial-toh#guards\n - guide/router-tutorial-toh#milestone-5-route-guards\n - guide/router-tutorial-toh#optional-route-parameters\n - guide/router-tutorial-toh#pathmatch\n - guide/router-tutorial-toh#query-parameters\n - guide/router-tutorial-toh#resolve-guard\n - start\n - tutorial\n - https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\n - https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/router.md?message=docs%3A%20请简述你的修改...\n - https://tools.ietf.org/html/rfc3986#section-5.2.2\n-->"
}