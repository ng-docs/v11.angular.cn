{"id":"guide/dependency-injection-providers","title":"Dependency providers","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/dependency-injection-providers.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"dependency-providers\" translation-result=\"on\">依赖提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#dependency-providers\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"dependency-providers\">Dependency providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#dependency-providers\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">通过配置提供者，你可以把服务提供给那些需要它们的应用部件。</p><p translation-origin=\"off\">By configuring providers, you can make services available to the parts of your application that need them.</p>\n\n<p translation-result=\"on\">依赖<a href=\"guide/glossary#provider\">提供者</a>会使用 <a href=\"guide/glossary#di-token\">DI 令牌</a>来配置注入器，注入器会用它来提供这个依赖值的具体的、运行时版本。</p><p translation-origin=\"off\">A dependency <a href=\"guide/glossary#provider\">provider</a> configures an injector with a <a href=\"guide/glossary#di-token\">DI token</a>, which that injector uses to provide the runtime version of a dependency value.</p>\n\n<h2 id=\"specifying-a-provider-token\" translation-result=\"on\">指定提供者令牌<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#specifying-a-provider-token\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"specifying-a-provider-token\">Specifying a provider token<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#specifying-a-provider-token\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果你把服务类指定为提供者令牌，那么注入器的默认行为是用 <code>new</code> 来实例化那个类。</p><p translation-origin=\"off\">If you specify the service class as the provider token, the default behavior is for the injector to instantiate that class with <code>new</code>.</p>\n\n<p translation-result=\"on\">在下面这个例子中，<code>Logger</code> 类提供了 <code>Logger</code> 的实例。</p><p translation-origin=\"off\">In the following example, the <code>Logger</code> class provides a <code>Logger</code> instance.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<p translation-result=\"on\">不过，你也可以用一个替代提供者来配置注入器，这样就可以指定另一些同样能提供日志功能的对象。</p><p translation-origin=\"off\">You can, however, configure an injector with an alternative provider in order to deliver some other object that provides the needed logging functionality.</p>\n\n<p translation-result=\"on\">你可以使用服务类来配置注入器，也可以提供一个替代类、一个对象或一个工厂函数。</p><p translation-origin=\"off\">You can configure an injector with a service class, you can provide a substitute class, an object, or a factory function.</p>\n\n<a id=\"token\"></a>\n<a id=\"injection-token\"></a>\n<h2 id=\"dependency-injection-tokens\" translation-result=\"on\">依赖注入令牌<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#dependency-injection-tokens\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"dependency-injection-tokens\">Dependency injection tokens<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#dependency-injection-tokens\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当使用<a href=\"guide/glossary#provider\">提供者</a>配置<a href=\"guide/glossary#injector\">注入器</a>时，会将该提供者与<a href=\"guide/glossary#di-token\">依赖项注入令牌</a>（或叫 DI 令牌）关联起来。注入器允许 Angular 创建任何内部依赖项的映射。DI 令牌会充当该映射的键名。</p><p translation-origin=\"off\">When you configure an <a href=\"guide/glossary#injector\">injector</a> with a <a href=\"guide/glossary#provider\">provider</a>, you are associating that provider with a <a href=\"guide/glossary#di-token\">dependency injection token</a>, or DI token.\nThe injector allows Angular to create a map of any internal dependencies.\nThe DI token acts as a key to that map.</p>\n\n<p translation-result=\"on\">依赖项值是一个实例，而这个类的类型用作查找键。在这里，注入器使用 <code>HeroService</code> 类型作为令牌来查找 <code>heroService</code>。</p><p translation-origin=\"off\">The dependency value is an instance, and the class type serves as a lookup key.\nHere, the injector uses the <code>HeroService</code> type as the token for looking up <code>heroService</code>.</p>\n\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"get-hero-service\" header=\"src/app/injector.component.ts\">\nheroService: HeroService;\n\n</code-example>\n<p translation-result=\"on\">当你使用 <code>HeroService</code> 类的类型来定义构造函数参数时，Angular 会注入与这个 <code>HeroService</code> 类令牌相关联的服务：</p><p translation-origin=\"off\">When you define a constructor parameter with the <code>HeroService</code> class type, Angular knows to inject the service associated with that <code>HeroService</code> class token:</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\" header=\"src/app/heroes/hero-list.component.ts\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p translation-result=\"on\">尽管许多依赖项的值是通过类提供的，但扩展的 <code>provide</code> 对象使你可以将不同种类的提供者与 DI 令牌相关联。</p><p translation-origin=\"off\">Though classes provide many dependency values, the expanded <code>provide</code> object lets you associate different kinds of providers with a DI token.</p>\n\n<a id=\"provide\"></a>\n<h2 id=\"defining-providers\" translation-result=\"on\">定义提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#defining-providers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"defining-providers\">Defining providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#defining-providers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">类提供者的语法实际上是一种简写形式，它会扩展成一个由 <a href=\"api/core/Provider\"><code>Provider</code> 接口</a>定义的提供者配置对象。\n下面的代码片段展示了 <code>providers</code> 中给出的类会如何扩展成完整的提供者配置对象。</p><p translation-origin=\"off\">The class provider syntax is a shorthand expression that expands into a provider configuration, defined by the <a href=\"api/core/Provider\"><code>Provider</code> interface</a>.\nThe following example is the class provider syntax for providing a <code>Logger</code> class in the <code>providers</code> array.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<p translation-result=\"on\">Angular 把这个 <code>providers</code> 值扩展为一个完整的提供者对象，如下所示。</p><p translation-origin=\"off\">Angular expands the <code>providers</code> value into a full provider object as follows.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-3\">\n[{ provide: Logger, useClass: Logger }]\n\n</code-example>\n<p translation-result=\"on\">扩展的提供者配置是一个具有两个属性的对象字面量：</p><p translation-origin=\"off\">The expanded provider configuration is an object literal with two properties:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">  <code>provide</code> 属性存有<a href=\"guide/dependency-injection-providers#token\">令牌</a>，它作为一个 key，在定位依赖值和配置注入器时使用。</p><p translation-origin=\"off\">The <code>provide</code> property holds the <a href=\"guide/dependency-injection-providers#token\">token</a>\nthat serves as the key for both locating a dependency value and configuring the injector.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  第二个属性是一个提供者定义对象，它告诉注入器要如何创建依赖值。\n提供者定义对象中的 key 可以是 <code>useClass</code> —— 就像这个例子中一样。\n也可以是 <code>useExisting</code>、<code>useValue</code> 或 <code>useFactory</code>。\n每一个 key 都用于提供一种不同类型的依赖，我们稍后会讨论。</p><p translation-origin=\"off\">The second property is a provider definition object, which tells the injector how to create the dependency value.\nThe provider-definition key can be <code>useClass</code>, as in the example.\nIt can also be <code>useExisting</code>, <code>useValue</code>, or <code>useFactory</code>.\nEach of these keys provides a different type of dependency, as discussed below.</p>\n\n</li>\n</ul>\n<a id=\"class-provider\"></a>\n<h2 id=\"specifying-an-alternative-class-provider\" translation-result=\"on\">指定替代性的类提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#specifying-an-alternative-class-provider\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"specifying-an-alternative-class-provider\">Specifying an alternative class provider<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#specifying-an-alternative-class-provider\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">不同的类可以提供相同的服务。例如，以下代码告诉注入器，当组件使用 <code>Logger</code> 令牌请求一个 logger 时，给它返回一个 <code>BetterLogger</code>。</p><p translation-origin=\"off\">Different classes can provide the same service.\nFor example, the following code tells the injector to return a <code>BetterLogger</code> instance when the component asks for a logger using the <code>Logger</code> token.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-4\">\n[{ provide: Logger, useClass: BetterLogger }]\n\n</code-example>\n<a id=\"class-provider-dependencies\"></a>\n<h3 id=\"configuring-class-providers-with-dependencies\" translation-result=\"on\">配置带依赖的类提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#configuring-class-providers-with-dependencies\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"configuring-class-providers-with-dependencies\">Configuring class providers with dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#configuring-class-providers-with-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果替代类提供者有自己的依赖，那就在父模块或组件的元数据属性 <code>providers</code> 中指定那些依赖。</p><p translation-origin=\"off\">If the alternative class providers have their own dependencies, specify both providers in the <code>providers</code> metadata property of the parent module or component.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-5\">\n[ UserService,\n  { provide: Logger, useClass: EvenBetterLogger }]\n\n</code-example>\n<p translation-result=\"on\">在这个例子中，<code>EvenBetterLogger</code> 会在日志信息里显示用户名。\n这个 logger 要从注入的 <code>UserService</code> 实例中来获取该用户。</p><p translation-origin=\"off\">In this example, <code>EvenBetterLogger</code> displays the user name in the log message.\nThis logger gets the user from an injected <code>UserService</code> instance.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"EvenBetterLogger\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class EvenBetterLogger extends Logger {\n  constructor(private userService: UserService) { super(); }\n\n  log(message: string) {\n    const name = this.userService.user.name;\n    super.log(`Message to ${name}: ${message}`);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">注入器需要提供这个新的日志服务以及该服务所依赖的 <code>UserService</code> 对象。</p><p translation-origin=\"off\">The injector needs providers for both this new logging service and its dependent <code>UserService</code>.</p>\n\n<a id=\"aliased-class-providers\"></a>\n<h3 id=\"aliasing-class-providers\" translation-result=\"on\">别名类提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#aliasing-class-providers\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"aliasing-class-providers\">Aliasing class providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#aliasing-class-providers\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要为类提供者设置别名，请在 <code>providers</code> 数组中使用 <code>useExisting</code> 属性指定别名和类提供者。</p><p translation-origin=\"off\">To alias a class provider, specify the alias and the class provider in the <code>providers</code> array with the <code>useExisting</code> property.</p>\n\n<p translation-result=\"on\">在下面的例子中，当组件请求新的或旧的记录器时，注入器都会注入一个 <code>NewLogger</code> 的实例。\n通过这种方式，<code>OldLogger</code> 就成了 <code>NewLogger</code> 的别名。</p><p translation-origin=\"off\">In the following example, the injector injects the singleton instance of <code>NewLogger</code> when the component asks for either the new or the old logger.\nIn this way, <code>OldLogger</code> is an alias for <code>NewLogger</code>.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6b\">\n[ NewLogger,\n  // Alias OldLogger w/ reference to NewLogger\n  { provide: OldLogger, useExisting: NewLogger}]\n\n</code-example>\n<p translation-result=\"on\">请确保你没有使用 <code>useClass</code> 来把 <code>OldLogger</code> 设为 <code>NewLogger</code> 的别名，因为如果这样做它就会创建两个不同的 <code>NewLogger</code> 实例。</p><p translation-origin=\"off\">Be sure you don't alias <code>OldLogger</code> to <code>NewLogger</code> with <code>useClass</code>, as this creates two different <code>NewLogger</code> instances.</p>\n\n<a id=\"provideparent\"></a>\n<h2 id=\"aliasing-a-class-interface\" translation-result=\"on\">为类接口指定别名<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#aliasing-a-class-interface\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"aliasing-a-class-interface\">Aliasing a class interface<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#aliasing-a-class-interface\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">通常，编写同一个父组件别名提供者的变体时会使用<a href=\"guide/dependency-injection-in-action#forwardref\">forwardRef</a>，如下所示。</p><p translation-origin=\"off\">Generally, writing variations of the same parent alias provider uses <a href=\"guide/dependency-injection-in-action#forwardref\">forwardRef</a> as follows.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => AlexComponent) }],\n\n</code-example>\n<p translation-result=\"on\">为简化你的代码，可以使用辅助函数 <code>provideParent()</code> 来把这个逻辑提取到一个辅助函数中。</p><p translation-origin=\"off\">To streamline your code, you can extract that logic into a helper function using the <code>provideParent()</code> helper function.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"provide-the-parent\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\">\n// Helper method to provide the current component instance in the name of a `parentType`.\nexport function provideParent\n  (component: any) {\n    return { provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => component) };\n  }\n\n</code-example>\n<p translation-result=\"on\">现在，你可以为组件添加一个更容易阅读和理解的父提供者。</p><p translation-origin=\"off\">Now you can add a parent provider to your components that's easier to read and understand.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alice-providers\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\">\nproviders:  [ provideParent(AliceComponent) ]\n\n</code-example>\n<h3 id=\"aliasing-multiple-class-interfaces\" translation-result=\"on\">为多个类接口指定别名<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#aliasing-multiple-class-interfaces\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"aliasing-multiple-class-interfaces\">Aliasing multiple class interfaces<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#aliasing-multiple-class-interfaces\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要为多个父类型指定别名（每个类型都有自己的类接口令牌），请配置 <code>provideParent()</code> 以接受更多的参数。</p><p translation-origin=\"off\">To alias multiple parent types, each with its own class interface token, configure <code>provideParent()</code> to accept more arguments.</p>\n\n<p translation-result=\"on\">这是一个修订版本，默认值为 <code>parent</code> 但同时也接受另一个父类接口作为可选的第二参数。</p><p translation-origin=\"off\">Here's a revised version that defaults to <code>parent</code> but also accepts an optional second parameter for a different parent class interface.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"provide-parent\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\">\n// Helper method to provide the current component instance in the name of a `parentType`.\n// The `parentType` defaults to `Parent` when omitting the second parameter.\nexport function provideParent\n  (component: any, parentType?: any) {\n    return { provide: parentType || Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() => component) };\n  }\n\n</code-example>\n<p translation-result=\"on\">接下来，要使用 <code>provideParent()</code>，请传入第二参数，这里是 <code>DifferentParent</code>。</p><p translation-origin=\"off\">Next, to use <code>provideParent()</code> with a different parent type, provide a second argument, here <code>DifferentParent</code>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"beth-providers\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\">\nproviders:  [ provideParent(BethComponent, DifferentParent) ]\n\n</code-example>\n<a id=\"value-provider\"></a>\n<h2 id=\"injecting-an-object\" translation-result=\"on\">注入一个对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#injecting-an-object\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"injecting-an-object\">Injecting an object<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#injecting-an-object\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要注入一个对象，可以用 <code>useValue</code> 选项来配置注入器。\n下面的提供者定义对象使用 <code>useValue</code> 作为 key 来把该变量与 <code>Logger</code> 令牌关联起来。</p><p translation-origin=\"off\">To inject an object, configure the injector with the <code>useValue</code> option.\nThe following provider object uses the <code>useValue</code> key to associate the variable with the <code>Logger</code> token.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-7\">\n[{ provide: Logger, useValue: SilentLogger }]\n\n</code-example>\n<p translation-result=\"on\">在这个例子中，<code>SilentLogger</code> 是一个充当记录器角色的对象。</p><p translation-origin=\"off\">In this example, <code>SilentLogger</code> is an object that fulfills the logger role.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"silent-logger\">\n// An object in the shape of the logger service\nfunction silentLoggerFn() {}\n\nexport const SilentLogger = {\n  logs: ['Silent logger says \"Shhhhh!\". Provided via \"useValue\"'],\n  log: silentLoggerFn\n};\n\n</code-example>\n<a id=\"non-class-dependencies\"></a>\n<h3 id=\"injecting-a-configuration-object\" translation-result=\"on\">注入一个配置对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#injecting-a-configuration-object\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"injecting-a-configuration-object\">Injecting a configuration object<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#injecting-a-configuration-object\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">常用的对象字面量是配置对象。下列配置对象包括应用的标题和 Web API 的端点地址。</p><p translation-origin=\"off\">A common use case for object literals is a configuration object.\nThe following configuration object includes the title of the application and the address of a web API endpoint.</p>\n\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"config\" header=\"src/app/app.config.ts (excerpt)\">\nexport const HERO_DI_CONFIG: AppConfig = {\n  apiEndpoint: 'api.heroes.com',\n  title: 'Dependency Injection'\n};\n\n\n</code-example>\n<p translation-result=\"on\">要提供并注入配置对象，请在 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 的 <code>providers</code> 数组中指定该对象。</p><p translation-origin=\"off\">To provide and inject the configuration object, specify the object in the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> <code>providers</code> array.</p>\n\n<code-example path=\"dependency-injection/src/app/app.module.ts\" region=\"providers\" header=\"src/app/app.module.ts (providers)\">\nproviders: [\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<a id=\"injectiontoken\"></a>\n<h3 id=\"using-an-injectiontoken-object\" translation-result=\"on\">使用 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#using-an-injectiontoken-object\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"using-an-injectiontoken-object\">Using an <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> object<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#using-an-injectiontoken-object\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以定义和使用一个 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 对象来为非类的依赖选择一个提供者令牌。下列例子定义了一个类型为 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 的 <code>APP_CONFIG</code> 。</p><p translation-origin=\"off\">You can define and use an <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> object for choosing a provider token for non-class dependencies.\nThe following example defines a token, <code>APP_CONFIG</code> of the type <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code>.</p>\n\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"token\" header=\"src/app/app.config.ts\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const APP_CONFIG = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&#x3C;AppConfig>('app.config');\n\n</code-example>\n<p translation-result=\"on\">可选的参数 <code>&#x3C;AppConfig></code> 和令牌描述 <code>app.config</code> 指明了此令牌的用途。</p><p translation-origin=\"off\">The optional type parameter, <code>&#x3C;AppConfig></code>, and the token description, <code>app.config</code>, specify the token's purpose.</p>\n\n<p translation-result=\"on\">接着，用 <code>APP_CONFIG</code> 这个 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 对象在组件中注册依赖提供者。</p><p translation-origin=\"off\">Next, register the dependency provider in the component using the <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> object of <code>APP_CONFIG</code>.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" header=\"src/app/providers.component.ts\" region=\"providers-9\">\nproviders: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }]\n\n</code-example>\n<p translation-result=\"on\">现在，借助参数装饰器 <code>@<a href=\"api/core/Inject-1\" class=\"code-anchor\">Inject</a>()</code>，你可以把这个配置对象注入到构造函数中。</p><p translation-origin=\"off\">Now you can inject the configuration object into the constructor with <code>@<a href=\"api/core/Inject-1\" class=\"code-anchor\">Inject</a>()</code> parameter decorator.</p>\n\n<code-example path=\"dependency-injection/src/app/app.component.2.ts\" region=\"ctor\" header=\"src/app/app.component.ts\">\nconstructor(@<a href=\"api/core/Inject-1\" class=\"code-anchor\">Inject</a>(APP_CONFIG) config: AppConfig) {\n  this.title = config.title;\n}\n\n</code-example>\n<a id=\"di-and-interfaces\"></a>\n<h4 id=\"interfaces-and-dependency-injection\" translation-result=\"on\">接口和依赖注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#interfaces-and-dependency-injection\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"interfaces-and-dependency-injection\">Interfaces and dependency injection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#interfaces-and-dependency-injection\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">虽然 TypeScript 的 <code>AppConfig</code> 接口可以在类中提供类型支持，但它在依赖注入时却没有任何作用。在 TypeScript 中，接口是一项设计期工件，它没有可供 DI 框架使用的运行时表示形式或令牌。</p><p translation-origin=\"off\">Though the TypeScript <code>AppConfig</code> interface supports typing within the class, the <code>AppConfig</code> interface plays no role in dependency injection.\nIn TypeScript, an interface is a design-time artifact, and doesn't have a runtime representation, or token, that the DI framework can use.</p>\n\n<p translation-result=\"on\">当转译器把 TypeScript 转换成 JavaScript 时，接口就会消失，因为 JavaScript 没有接口。</p><p translation-origin=\"off\">When the transpiler changes TypeScript to JavaScript, the interface disappears because JavaScript doesn't have interfaces.</p>\n\n<p translation-result=\"on\">由于 Angular 在运行期没有接口，所以该接口不能作为令牌，也不能注入它。</p><p translation-origin=\"off\">Since there is no interface for Angular to find at runtime, the interface cannot be a token, nor can you inject it.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9-interface\">\n// Can't use interface as provider token\n[{ provide: AppConfig, useValue: HERO_DI_CONFIG })]\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-9-ctor-interface\">\n// Can't inject using the interface as the parameter type\nconstructor(private config: AppConfig){ }\n\n</code-example>\n<a id=\"factory-provider\"></a>\n<a id=\"factory-providers\"></a>\n<h2 id=\"using-factory-providers\" translation-result=\"on\">使用工厂提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#using-factory-providers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"using-factory-providers\">Using factory providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#using-factory-providers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要想根据运行前尚不可用的信息创建可变的依赖值，可以使用工厂提供者。</p><p translation-origin=\"off\">To create a changeable, dependent value based on information unavailable before run time, you can use a factory provider.</p>\n\n<p translation-result=\"on\">在下面的例子中，只有授权用户才能看到 <code>HeroService</code> 中的秘密英雄。授权可能在单个应用会话期间发生变化，比如改用其他用户登录。</p><p translation-origin=\"off\">In the following example, only authorized users should see secret heroes in the <code>HeroService</code>.\nAuthorization can change during the course of a single application session, as when a different user logs in .</p>\n\n<p translation-result=\"on\">要想在 <code>UserService</code> 和 <code>HeroService</code> 中保存敏感信息，就要给 <code>HeroService</code> 的构造函数传一个逻辑标志来控制秘密英雄的显示。</p><p translation-origin=\"off\">To keep security-sensitive information in <code>UserService</code> and out of <code>HeroService</code>, give the <code>HeroService</code> constructor a boolean flag to control display of secret heroes.</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.ts\" region=\"internals\" header=\"src/app/heroes/hero.service.ts (excerpt)\">\nconstructor(\n  private logger: Logger,\n  private isAuthorized: boolean) { }\n\ngetHeroes() {\n  const auth = this.isAuthorized ? 'authorized ' : 'unauthorized';\n  this.logger.log(`Getting heroes for ${auth} user.`);\n  return HEROES.filter(hero => this.isAuthorized || !hero.isSecret);\n}\n\n</code-example>\n<p translation-result=\"on\">要实现 <code>isAuthorized</code> 标志，可以用工厂提供者来为 <code>HeroService</code> 创建一个新的 logger 实例。</p><p translation-origin=\"off\">To implement the <code>isAuthorized</code> flag, use a factory provider to create a new logger instance for <code>HeroService</code>.</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"factory\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\">\nconst heroServiceFactory = (logger: Logger, userService: UserService) => {\n  return new HeroService(logger, userService.user.isAuthorized);\n};\n\n</code-example>\n<p translation-result=\"on\">这个工厂函数可以访问 <code>UserService</code>。你可以同时把 <code>Logger</code> 和 <code>UserService</code> 注入到工厂提供者中，这样注入器就可以把它们传给工厂函数了。</p><p translation-origin=\"off\">The factory function has access to <code>UserService</code>.\nYou inject both <code>Logger</code> and <code>UserService</code> into the factory provider so the injector can pass them along to the factory function.</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"provider\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\">\nexport let heroServiceProvider =\n  { provide: HeroService,\n    useFactory: heroServiceFactory,\n    deps: [Logger, UserService]\n  };\n\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\"><code>useFactory</code> 字段指定该提供者是一个工厂函数，其实现代码是 <code>heroServiceFactory</code>。</p><p translation-origin=\"off\">The <code>useFactory</code> field specifies that the provider is a factory function whose implementation is <code>heroServiceFactory</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  <code>deps</code> 属性是一个<a href=\"guide/dependency-injection-providers#token\">提供者令牌</a>数组。 <code>Logger</code> 和 <code>UserService</code> 类都是自己类提供者的令牌。该注入器解析了这些令牌，并把相应的服务注入到 <code>heroServiceFactory</code> 工厂函数的参数中。</p><p translation-origin=\"off\">The <code>deps</code> property is an array of <a href=\"guide/dependency-injection-providers#token\">provider tokens</a>.\nThe <code>Logger</code> and <code>UserService</code> classes serve as tokens for their own class providers.\nThe injector resolves these tokens and injects the corresponding services into the matching <code>heroServiceFactory</code> factory function parameters.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">通过把工厂提供者导出为变量 <code>heroServiceProvider</code>，就能让工厂提供者变得可复用。</p><p translation-origin=\"off\">Capturing the factory provider in the exported variable, <code>heroServiceProvider</code>, makes the factory provider reusable.</p>\n\n<p translation-result=\"on\">下面这两个并排的例子展示了在 <code>providers</code> 数组中，如何用 <code>heroServiceProvider</code> 替换 <code>HeroService</code></p><p translation-origin=\"off\">The following side-by-side example shows how <code>heroServiceProvider</code> replaces <code>HeroService</code> in the <code>providers</code> array.</p>\n\n<code-tabs>\n\n  <code-pane header=\"src/app/heroes/heroes.component (v3)\" path=\"dependency-injection/src/app/heroes/heroes.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { heroServiceProvider } from './hero.service.provider';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ heroServiceProvider ],\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/heroes.component (v2)\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ HeroService ],\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n</code-tabs>\n\n  \n</div>\n\n\n<!-- links to this doc:\n - api/core/Injector-0\n - api/core/StaticProvider\n - guide/dependency-injection\n - guide/dependency-injection-in-action\n - guide/hierarchical-dependency-injection\n - guide/providers\n - guide/upgrade\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Inject-1\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/NgModule\n - api/core/Provider\n - api/core/forwardRef\n - guide/dependency-injection-in-action#forwardref\n - guide/dependency-injection-providers#aliasing-a-class-interface\n - guide/dependency-injection-providers#aliasing-class-providers\n - guide/dependency-injection-providers#aliasing-multiple-class-interfaces\n - guide/dependency-injection-providers#configuring-class-providers-with-dependencies\n - guide/dependency-injection-providers#defining-providers\n - guide/dependency-injection-providers#dependency-injection-tokens\n - guide/dependency-injection-providers#dependency-providers\n - guide/dependency-injection-providers#injecting-a-configuration-object\n - guide/dependency-injection-providers#injecting-an-object\n - guide/dependency-injection-providers#interfaces-and-dependency-injection\n - guide/dependency-injection-providers#specifying-a-provider-token\n - guide/dependency-injection-providers#specifying-an-alternative-class-provider\n - guide/dependency-injection-providers#token\n - guide/dependency-injection-providers#using-an-injectiontoken-object\n - guide/dependency-injection-providers#using-factory-providers\n - guide/glossary#di-token\n - guide/glossary#injector\n - guide/glossary#provider\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/dependency-injection-providers.md?message=docs%3A%20请简述你的修改...\n-->"}