{"id":"guide/testing-utility-apis","title":"Testing Utility APIs","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/testing-utility-apis.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"testing-utility-apis\" translation-result=\"on\">测试实用工具 API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#testing-utility-apis\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"testing-utility-apis\">Testing Utility APIs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#testing-utility-apis\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本页面描述了一些最有用的 Angular 测试特性。</p><p translation-origin=\"off\">This page describes the most useful Angular testing features.</p>\n\n<p translation-result=\"on\">Angular 测试实用工具包括 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>、<code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 以及一些控制测试环境的函数。 <a href=\"guide/testing-utility-apis#testbed-api-summary\"><em>TestBed</em></a> 和 <a href=\"guide/testing-utility-apis#component-fixture-api-summary\"><em>ComponentFixture</em></a> 类是单独介绍的。</p><p translation-origin=\"off\">The Angular testing utilities include the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>, the <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code>, and a handful of functions that control the test environment.\nThe <a href=\"guide/testing-utility-apis#testbed-api-summary\"><em>TestBed</em></a> and <a href=\"guide/testing-utility-apis#component-fixture-api-summary\"><em>ComponentFixture</em></a> classes are covered separately.</p>\n\n<p translation-result=\"on\">下面是一些独立函数的摘要，以使用频率排序：</p><p translation-origin=\"off\">Here's a summary of the stand-alone functions, in order of likely utility:</p>\n\n<table>\n  <tbody><tr>\n    <th>\n<p translation-result=\"on\">      函数</p><p translation-origin=\"off\">      Function</p>\n\n    </th>\n    <th>\n<p translation-result=\"on\">      说明</p><p translation-origin=\"off\">      Description</p>\n\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a></code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      在一个特殊的<em> async 测试区域</em>中运行测试（<code>it</code>）的函数体或准备函数（<code>beforeEach</code>）。\n参阅<a href=\"guide/testing-components-scenarios#waitForAsync\">前面的讨论</a>。</p><p translation-origin=\"off\">      Runs the body of a test (<code>it</code>) or setup (<code>beforeEach</code>) function within a special <em>async test zone</em>.\nSee <a href=\"guide/testing-components-scenarios#waitForAsync\">discussion above</a>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      在一个特殊的<em> fakeAsync 测试区域</em>中运行测试（<code>it</code>）的函数体，以便启用线性风格的控制流。\n参阅<a href=\"guide/testing-components-scenarios#fake-async\">前面的讨论</a>。</p><p translation-origin=\"off\">      Runs the body of a test (<code>it</code>) within a special <em>fakeAsync test zone</em>, enabling\na linear control flow coding style. See <a href=\"guide/testing-components-scenarios#fake-async\">discussion above</a>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a></code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      通过在<em> fakeAsync 测试区域</em>中刷新定时器和微任务（micro-task）队列来仿真时间的流逝以及异步活动的完成。</p><p translation-origin=\"off\">      Simulates the passage of time and the completion of pending asynchronous activities\nby flushing both <em>timer</em> and <em>micro-task</em> queues within the <em>fakeAsync test zone</em>.</p>\n\n      <div class=\"alert is-helpful\">\n<p translation-result=\"on\">      好奇和执着的读者可能会喜欢这篇长博客：\n\"<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\"><em>Tasks, microtasks, queues and schedules</em></a>\".</p><p translation-origin=\"off\">      The curious, dedicated reader might enjoy this lengthy blog post,\n<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">\"<em>Tasks, microtasks, queues and schedules</em>\"</a>.</p>\n\n      </div>\n<p translation-result=\"on\">      接受一个可选参数，它可以把虚拟时钟往前推进特定的微秒数。\n清除调度到那个时间帧中的异步活动。\n参阅<a href=\"guide/testing-components-scenarios#tick\">前面的讨论</a>。</p><p translation-origin=\"off\">      Accepts an optional argument that moves the virtual clock forward\nby the specified number of milliseconds,\nclearing asynchronous activities scheduled within that timeframe.\nSee <a href=\"guide/testing-components-scenarios#tick\">discussion above</a>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>       <code>inject</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      从当前的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 注入器中把一个或多个服务注入到一个测试函数中。\n它不能用于注入组件自身提供的服务。\n参阅 <a href=\"guide/testing-components-scenarios#get-injected-services\"><code>debugElement.injector</code></a> 部分的讨论。</p><p translation-origin=\"off\">      Injects one or more services from the current <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> injector into a test function.\nIt cannot inject a service provided by the component itself.\nSee discussion of the <a href=\"guide/testing-components-scenarios#get-injected-services\">debugElement.injector</a>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      当 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code> 测试程序以正在运行的计时器事件<strong>任务</strong>（排队中的 <code>setTimeOut</code> 和 <code>setInterval</code> 的回调）结束时，\n测试会失败，并显示一条明确的错误信息。</p><p translation-origin=\"off\">      When a <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> test ends with pending timer event <em>tasks</em> (queued <code>setTimeOut</code> and <code>setInterval</code> callbacks),\nthe test fails with a clear error message.</p>\n\n<p translation-result=\"on\">      一般来讲，测试程序应该以无排队任务结束。\n当待执行计时器任务存在时，调用 <code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code> 来触发<strong>任务</strong>队列，防止该错误发生。</p><p translation-origin=\"off\">      In general, a test should end with no queued tasks.\nWhen pending timer tasks are expected, call <code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code> to flush the <em>task</em> queue\nand avoid the error.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      当 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code> 测试程序以待执行<strong>微任务</strong>（比如未解析的承诺）结束时，测试会失败并显示明确的错误信息。</p><p translation-origin=\"off\">      When a <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> test ends with pending <em>micro-tasks</em> such as unresolved promises,\nthe test fails with a clear error message.</p>\n\n<p translation-result=\"on\">      一般来说，测试应该等待微任务结束。\n当待执行微任务存在时，调用 <code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code> 来触发<strong>微任务</strong>队列，防止该错误发生。</p><p translation-origin=\"off\">      In general, a test should wait for micro-tasks to finish.\nWhen pending microtasks are expected, call <code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code> to flush the  <em>micro-task</em> queue\nand avoid the error.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      一个服务提供者令牌，用于开启<a href=\"guide/testing-components-scenarios#automatic-change-detection\">自动变更检测</a>。</p><p translation-origin=\"off\">      A provider token for a service that turns on <a href=\"guide/testing-components-scenarios#automatic-change-detection\">automatic change detection</a>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a></code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      获取当前 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 实例。\n通常用不上，因为 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的静态类方法已经够用。\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 实例有一些很少需要用到的方法，它们没有对应的静态方法。</p><p translation-origin=\"off\">      Gets the current instance of the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>.\nUsually unnecessary because the static class methods of the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> class are typically sufficient.\nThe <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> instance exposes a few rarely used members that are not available as\nstatic methods.</p>\n\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"testbed-class-summary\"></a>\n<h2 id=\"testbed-class-summary\" translation-result=\"on\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 类摘要<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#testbed-class-summary\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"testbed-class-summary\"><em>TestBed</em> class summary<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#testbed-class-summary\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 类是 Angular 测试工具的主要类之一。它的 API 很庞大，可能有点过于复杂，直到你一点一点的探索它们。\n阅读本章前面的部分，了解了基本的知识以后，再试着了解完整 API。</p><p translation-origin=\"off\">The <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> class is one of the principal Angular testing utilities.\nIts API is quite large and can be overwhelming until you've explored it,\na little at a time. Read the early part of this guide first\nto get the basics before trying to absorb the full API.</p>\n\n<p translation-result=\"on\">传给 <code>configureTestingModule</code> 的模块定义是 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 元数据属性的子集。</p><p translation-origin=\"off\">The module definition passed to <code>configureTestingModule</code>\nis a subset of the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> metadata properties.</p>\n\n<code-example language=\"javascript\">\n  type <a href=\"api/core/testing/TestModuleMetadata\" class=\"code-anchor\">TestModuleMetadata</a> = {\n    providers?: any[];\n    declarations?: any[];\n    imports?: any[];\n    schemas?: Array&#x3C;<a href=\"api/core/SchemaMetadata\" class=\"code-anchor\">SchemaMetadata</a> | any[]>;\n  };\n</code-example>\n<a id=\"metadata-override-object\"></a>\n<p translation-result=\"on\">每一个重载方法接受一个 <code><a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&#x3C;T></code>，这里 <code>T</code> 是适合这个方法的元数据类型，也就是 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>、<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>、<code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 或者 <code>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code> 的参数。</p><p translation-origin=\"off\">Each override method takes a <code><a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&#x3C;T></code> where <code>T</code> is the kind of metadata\nappropriate to the method, that is, the parameter of an <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>,\n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>, <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>, or <code>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code>.</p>\n\n<code-example language=\"javascript\">\n  type <a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&#x3C;T> = {\n    add?: Partial&#x3C;T>;\n    remove?: Partial&#x3C;T>;\n    set?: Partial&#x3C;T>;\n  };\n</code-example>\n<a id=\"testbed-methods\"></a>\n<a id=\"testbed-api-summary\"></a>\n<p translation-result=\"on\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的 API 包含了一系列静态类方法，它们更新或者引用<strong>全局</strong>的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 实例。</p><p translation-origin=\"off\">The <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> API consists of static class methods that either update or reference a <em>global</em> instance of the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>.</p>\n\n<p translation-result=\"on\">在内部，所有静态方法在 <code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a>()</code> 函数返回的当前运行时间的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 实例上都有对应的方法。</p><p translation-origin=\"off\">Internally, all static methods cover methods of the current runtime <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> instance,\nwhich is also returned by the <code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a>()</code> function.</p>\n\n<p translation-result=\"on\">在 <code>BeforeEach()</code> 内调用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 方法，以确保在运行每个单独测试时，都有崭新的开始。</p><p translation-origin=\"off\">Call <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> methods <em>within</em> a <code>beforeEach()</code> to ensure a fresh start before each individual test.</p>\n\n<p translation-result=\"on\">这里列出了最重要的静态方法，以使用频率排序：</p><p translation-origin=\"off\">Here are the most important static methods, in order of likely utility.</p>\n\n<table>\n  <tbody><tr>\n    <th>\n<p translation-result=\"on\">      方法</p><p translation-origin=\"off\">      Methods</p>\n\n    </th>\n    <th>\n<p translation-result=\"on\">      说明</p><p translation-origin=\"off\">      Description</p>\n\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>configureTestingModule</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      测试垫片（<code>karma-test-shim</code>, <code>browser-test-shim</code>）创建了<a href=\"guide/testing\">初始测试环境</a>和默认测试模块。\n默认测试模块是使用基本声明和一些 Angular 服务替代品，它们是所有测试程序都需要的。</p><p translation-origin=\"off\">      The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>)\nestablish the <a href=\"guide/testing\">initial test environment</a> and a default testing module.\nThe default testing module is configured with basic declaratives and some Angular service substitutes that every tester needs.</p>\n\n<p translation-result=\"on\">      调用 <code>configureTestingModule</code> 来为一套特定的测试定义测试模块配置，添加和删除导入、（组件、指令和管道的）声明和服务提供者。</p><p translation-origin=\"off\">      Call <code>configureTestingModule</code> to refine the testing module configuration for a particular set of tests\nby adding and removing imports, declarations (of components, directives, and pipes), and providers.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>compileComponents</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      在配置好测试模块之后，异步编译它。\n如果测试模块中的<em>任何一个</em>组件具有 <code>templateUrl</code> 或 <code>styleUrls</code>，那么你<strong>必须</strong>调用这个方法，因为获取组件的模板或样式文件必须是异步的。\n参阅<a href=\"guide/testing-components-scenarios#compile-components\">前面的讨论</a>。</p><p translation-origin=\"off\">      Compile the testing module asynchronously after you've finished configuring it.\nYou <strong>must</strong> call this method if <em>any</em> of the testing module components have a <code>templateUrl</code>\nor <code>styleUrls</code> because fetching component template and style files is necessarily asynchronous.\nSee <a href=\"guide/testing-components-scenarios#compile-components\">above</a>.</p>\n\n<p translation-result=\"on\">      调用完 <code>compileComponents</code> 之后，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置就会在当前测试期间被冻结。</p><p translation-origin=\"off\">      After calling <code>compileComponents</code>, the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration is frozen for the duration of the current spec.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>createComponent<t></t></code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      基于当前 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置创建一个类型为 T 的组件实例。\n一旦调用，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置就会在当前测试期间被冻结。</p><p translation-origin=\"off\">      Create an instance of a component of type <code>T</code> based on the current <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration.\nAfter calling <code>compileComponent</code>, the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration is frozen for the duration of the current spec.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>overrideModule</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      替换指定的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的元数据。回想一下，模块可以导入其它模块。\n<code>overrideModule</code> 方法可以深入到当前测试模块深处，修改其中一个内部模块。</p><p translation-origin=\"off\">      Replace metadata for the given <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>. Recall that modules can import other modules.\nThe <code>overrideModule</code> method can reach deeply into the current testing module to\nmodify one of these inner modules.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>overrideComponent</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      替换指定组件类的元数据，该组件类可能嵌套在一个很深的内部模块中。</p><p translation-origin=\"off\">      Replace metadata for the given component class, which could be nested deeply\nwithin an inner module.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>overrideDirective</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      替换指定指令类的元数据，该指令可能嵌套在一个很深的内部模块中。</p><p translation-origin=\"off\">      Replace metadata for the given directive class, which could be nested deeply\nwithin an inner module.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>overridePipe</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      替换指定管道类的元数据，该管道可能嵌套在一个很深的内部模块中。</p><p translation-origin=\"off\">      Replace metadata for the given pipe class, which could be nested deeply\nwithin an inner module.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <a id=\"testbed-inject\"></a></p>\n<p>      <code>inject</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      从当前 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 注入器获取一个服务。</p><p translation-origin=\"off\">      Retrieve a service from the current <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> injector.</p>\n\n<p translation-result=\"on\">      <code>inject</code> 函数通常都能胜任这项工作，但是如果它没法提供该服务时就会抛出一个异常。</p><p translation-origin=\"off\">      The <code>inject</code> function is often adequate for this purpose.\nBut <code>inject</code> throws an error if it can't provide the service.</p>\n\n<p translation-result=\"on\">      如果该服务是可选的呢？</p><p translation-origin=\"off\">      What if the service is optional?</p>\n\n<p translation-result=\"on\">      <code>TestBed.inject()</code> 方法可以接受可选的第二参数，当 Angular 找不到指定的服务提供者时，就会返回该对象（下面这个例子中是 <code>null</code> ）：</p><p translation-origin=\"off\">      The <code>TestBed.inject()</code> method takes an optional second parameter,\nthe object to return if Angular can't find the provider\n(<code>null</code> in this example):</p>\n\n<p>      <code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"testbed-get-w-null\" header=\"app/demo/demo.testbed.spec.ts\">\nservice = TestBed.inject(NotProvided, null); // service is null\n\n</code-example></p>\n<p translation-result=\"on\">      调用了 <code>TestBed.inject</code> 之后然后通过调用，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置就会在当前测试期间被冻结。</p><p translation-origin=\"off\">      After calling <code>TestBed.inject</code>, the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration is frozen for the duration of the current spec.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <a id=\"testbed-initTestEnvironment\"></a></p>\n<p>      <code>initTestEnvironment</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      为整套测试的运行初始化测试环境。</p><p translation-origin=\"off\">      Initialize the testing environment for the entire test run.</p>\n\n<p translation-result=\"on\">      测试垫片(<code>karma-test-shim</code>, <code>browser-test-shim</code>)会为你调用它，所以你很少需要自己调用它。</p><p translation-origin=\"off\">      The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) call it for you\nso there is rarely a reason for you to call it yourself.</p>\n\n<p translation-result=\"on\">      这个方法只能被调用<strong>一次</strong>。如果确实需要在测试程序运行期间改变这个默认设置，那么先调用 <code>resetTestEnvironment</code>。</p><p translation-origin=\"off\">      You may call this method <em>exactly once</em>. If you must change\nthis default in the middle of your test run, call <code>resetTestEnvironment</code> first.</p>\n\n<p translation-result=\"on\">      指定 Angular 编译器工厂，<code><a href=\"api/core/PlatformRef\" class=\"code-anchor\">PlatformRef</a></code>，和默认 Angular 测试模块。\n以 <code>@angular/platform-&#x3C;platform_name>/testing/&#x3C;platform_name></code> 的形式提供非浏览器平台的替代品。</p><p translation-origin=\"off\">      Specify the Angular compiler factory, a <code><a href=\"api/core/PlatformRef\" class=\"code-anchor\">PlatformRef</a></code>, and a default Angular testing module.\nAlternatives for non-browser platforms are available in the general form\n<code>@angular/platform-&#x3C;platform_name>/testing/&#x3C;platform_name></code>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>resetTestEnvironment</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      重设初始测试环境，包括默认测试模块在内。</p><p translation-origin=\"off\">      Reset the initial test environment, including the default testing module.</p>\n\n    </td>\n  </tr>\n</tbody></table>\n<p translation-result=\"on\">少数 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 实例方法没有对应的静态方法。它们很少被使用。</p><p translation-origin=\"off\">A few of the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> instance methods are not covered by static <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> <em>class</em> methods.\nThese are rarely needed.</p>\n\n<a id=\"component-fixture-api-summary\"></a>\n<h2 id=\"the-componentfixture\" translation-result=\"on\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 类<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#the-componentfixture\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"the-componentfixture\">The <em>ComponentFixture</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#the-componentfixture\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>TestBed.createComponent&#x3C;T></code> 会创建一个组件 <code>T</code> 的实例，并为该组件返回一个强类型的 <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code>。</p><p translation-origin=\"off\">The <code>TestBed.createComponent&#x3C;T></code>\ncreates an instance of the component <code>T</code>\nand returns a strongly typed <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> for that component.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 的属性和方法提供了对组件、它的 DOM 和它的 Angular 环境方面的访问。</p><p translation-origin=\"off\">The <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> properties and methods provide access to the component,\nits DOM representation, and aspects of its Angular environment.</p>\n\n<a id=\"component-fixture-properties\"></a>\n<h3 id=\"componentfixture-properties\" translation-result=\"on\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 的属性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-properties\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"componentfixture-properties\"><em>ComponentFixture</em> properties<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-properties\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">下面是对测试最重要的属性，以使用频率排序：</p><p translation-origin=\"off\">Here are the most important properties for testers, in order of likely utility.</p>\n\n<table>\n  <tbody><tr>\n    <th>\n<p translation-result=\"on\">      属性</p><p translation-origin=\"off\">      Properties</p>\n\n    </th>\n    <th>\n<p translation-result=\"on\">      说明</p><p translation-origin=\"off\">      Description</p>\n\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>componentInstance</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      被 <code>TestBed.createComponent</code> 创建的组件类实例。</p><p translation-origin=\"off\">      The instance of the component class created by <code>TestBed.createComponent</code>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>debugElement</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      与组件根元素关联的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p><p translation-origin=\"off\">      The <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> associated with the root element of the component.</p>\n\n<p translation-result=\"on\">      <code>debugElement</code> 提供了在测试和调试期间深入探查组件及其 DOM 元素的功能。\n它对于测试者是一个极其重要的属性。它的大多数主要成员在<a href=\"guide/testing-utility-apis#debug-element-details\">后面</a>都有讲解。</p><p translation-origin=\"off\">      The <code>debugElement</code> provides insight into the component and its DOM element during test and debugging.\nIt's a critical property for testers. The most interesting members are covered <a href=\"guide/testing-utility-apis#debug-element-details\">below</a>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>nativeElement</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      组件的原生根 DOM 元素。</p><p translation-origin=\"off\">      The native DOM element at the root of the component.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>changeDetectorRef</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      组件的 <code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code>。</p><p translation-origin=\"off\">      The <code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code> for the component.</p>\n\n<p translation-result=\"on\">      在测试一个拥有 <code><a href=\"api/core/ChangeDetectionStrategy#OnPush\" class=\"code-anchor\">ChangeDetectionStrategy.OnPush</a></code> 的组件，或者在组件的变化测试在你的程序控制下时，<code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code> 是最重要的。</p><p translation-origin=\"off\">      The <code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code> is most valuable when testing a\ncomponent that has the <code><a href=\"api/core/ChangeDetectionStrategy#OnPush\" class=\"code-anchor\">ChangeDetectionStrategy.OnPush</a></code> method\nor the component's change detection is under your programmatic control.</p>\n\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"component-fixture-methods\"></a>\n<h3 id=\"componentfixture-methods\" translation-result=\"on\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 的方法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-methods\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"componentfixture-methods\"><em>ComponentFixture</em> methods<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-methods\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><strong>fixture</strong> 方法使 Angular 对组件树执行某些任务。\n在触发 Angular 行为来模拟的用户行为时，调用这些方法。</p><p translation-origin=\"off\">The <em>fixture</em> methods cause Angular to perform certain tasks on the component tree.\nCall these method to trigger Angular behavior in response to simulated user action.</p>\n\n<p translation-result=\"on\">下面是对测试最有用的方法。</p><p translation-origin=\"off\">Here are the most useful methods for testers.</p>\n\n<table>\n  <tbody><tr>\n    <th>\n<p translation-result=\"on\">      方法</p><p translation-origin=\"off\">      Methods</p>\n\n    </th>\n    <th>\n<p translation-result=\"on\">      说明</p><p translation-origin=\"off\">      Description</p>\n\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>detectChanges</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      为组件触发一轮变化检查。</p><p translation-origin=\"off\">      Trigger a change detection cycle for the component.</p>\n\n<p translation-result=\"on\">      调用它来初始化组件（它调用 <code>ngOnInit</code>）。或者在你的测试代码改变了组件的数据绑定属性值后调用它。\nAngular 不能检测到你已经改变了 <code>personComponent.name</code> 属性，也不会更新 <code>name</code> 的绑定，直到你调用了 <code>detectChanges</code>。</p><p translation-origin=\"off\">      Call it to initialize the component (it calls <code>ngOnInit</code>) and after your\ntest code, change the component's data bound property values.\nAngular can't see that you've changed <code>personComponent.name</code> and won't update the <code>name</code>\nbinding until you call <code>detectChanges</code>.</p>\n\n<p translation-result=\"on\">      之后，运行 <code>checkNoChanges</code>，来确认没有循环更新，除非它被这样调用：<code>detectChanges(false)</code>。</p><p translation-origin=\"off\">      Runs <code>checkNoChanges</code> afterwards to confirm that there are no circular updates unless\ncalled as <code>detectChanges(false)</code>;</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>autoDetectChanges</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      如果你希望这个夹具自动检测变更，就把这个设置为 <code>true</code>。</p><p translation-origin=\"off\">      Set this to <code>true</code> when you want the fixture to detect changes automatically.</p>\n\n<p translation-result=\"on\">      当自动检测打开时，测试 fixture 监听 <strong>zone</strong> 事件，并调用 <code>detectChanges</code>。\n当你的测试代码直接修改了组件属性值时，你还是要调用 <code>fixture.detectChanges</code> 来触发数据绑定更新。</p><p translation-origin=\"off\">      When autodetect is <code>true</code>, the test fixture calls <code>detectChanges</code> immediately\nafter creating the component. Then it listens for pertinent zone events\nand calls <code>detectChanges</code> accordingly.\nWhen your test code modifies component property values directly,\nyou probably still have to call <code>fixture.detectChanges</code> to trigger data binding updates.</p>\n\n<p translation-result=\"on\">      默认值是 <code>false</code>，喜欢对测试行为进行精细控制的测试者一般保持它为 <code>false</code>。</p><p translation-origin=\"off\">      The default is <code>false</code>. Testers who prefer fine control over test behavior\ntend to keep it <code>false</code>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>checkNoChanges</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      运行一次变更检测来确认没有待处理的变化。如果有未处理的变化，它将抛出一个错误。</p><p translation-origin=\"off\">      Do a change detection run to make sure there are no pending changes.\nThrows an exceptions if there are.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>isStable</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      如果 fixture 当前是<strong>稳定的</strong>，则返回 <code>true</code>。\n如果有异步任务没有完成，则返回 <code>false</code>。</p><p translation-origin=\"off\">      If the fixture is currently <em>stable</em>, returns <code>true</code>.\nIf there are async tasks that have not completed, returns <code>false</code>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>whenStable</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      返回一个承诺，在 fixture 稳定时解析。</p><p translation-origin=\"off\">      Returns a promise that resolves when the fixture is stable.</p>\n\n<p translation-result=\"on\">      要想在完成了异步活动或异步变更检测之后再继续测试，可以对那个承诺对象进行挂钩。\n参阅 <a href=\"guide/testing-components-scenarios#when-stable\">前面</a>。</p><p translation-origin=\"off\">      To resume testing after completion of asynchronous activity or\nasynchronous change detection, hook that promise.\nSee <a href=\"guide/testing-components-scenarios#when-stable\">above</a>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>destroy</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      触发组件的销毁。</p><p translation-origin=\"off\">      Trigger component destruction.</p>\n\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"debug-element-details\"></a>\n<h4 id=\"debugelement\"><em>DebugElement</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#debugelement\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 提供了对组件的 DOM 的访问。</p><p translation-origin=\"off\">The <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> provides crucial insights into the component's DOM representation.</p>\n\n<p translation-result=\"on\"><code>fixture.debugElement</code> 返回测试根组件的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>，通过它你可以访问（查询）fixture 的整个元素和组件子树。</p><p translation-origin=\"off\">From the test root component's <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> returned by <code>fixture.debugElement</code>,\nyou can walk (and query) the fixture's entire element and component subtrees.</p>\n\n<p translation-result=\"on\">下面是 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 最有用的成员，以使用频率排序。</p><p translation-origin=\"off\">Here are the most useful <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> members for testers, in approximate order of utility:</p>\n\n<table>\n  <tbody><tr>\n    <th>\n<p translation-result=\"on\">      成员</p><p translation-origin=\"off\">      Member</p>\n\n    </th>\n    <th>\n<p translation-result=\"on\">      说明</p><p translation-origin=\"off\">      Description</p>\n\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>nativeElement</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      与浏览器中 DOM 元素对应（WebWorkers 时，值为 null）。</p><p translation-origin=\"off\">      The corresponding DOM element in the browser (null for WebWorkers).</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      调用 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&#x3C;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>>)</code> 会在子树的任意深度中查找并返回能和<a href=\"guide/testing-utility-apis#query-predicate\">谓词函数</a>匹配的第一个 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p><p translation-origin=\"off\">      Calling <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&#x3C;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>>)</code> returns the first <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>\nthat matches the <a href=\"guide/testing-utility-apis#query-predicate\">predicate</a> at any depth in the subtree.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>queryAll</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      调用 <code>queryAll(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&#x3C;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>>)</code> 会在子树的任意深度中查找能和<a href=\"guide/testing-utility-apis#query-predicate\">谓词函数</a>匹配的所有 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p><p translation-origin=\"off\">      Calling <code>queryAll(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&#x3C;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>>)</code> returns all <code>DebugElements</code>\nthat matches the <a href=\"guide/testing-utility-apis#query-predicate\">predicate</a> at any depth in subtree.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>injector</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      宿主依赖注入器。\n比如，根元素的组件实例注入器。</p><p translation-origin=\"off\">      The host dependency injector.\nFor example, the root element's component instance injector.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>componentInstance</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      元素自己的组件实例（如果有）。</p><p translation-origin=\"off\">      The element's own component instance, if it has one.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>context</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      为元素提供父级上下文的对象。\n通常是控制该元素的祖级组件实例。</p><p translation-origin=\"off\">      An object that provides parent context for this element.\nOften an ancestor component instance that governs this element.</p>\n\n<p translation-result=\"on\">      当一个元素被 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 重复，它的上下文为 <code>NgForRow</code>，它的 <code>$implicit</code> 属性值是该行的实例值。\n比如，<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"</code> 里的 <code>hero</code>。</p><p translation-origin=\"off\">      When an element is repeated within <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>, the context is an <code>NgForRow</code> whose <code>$implicit</code>\nproperty is the value of the row instance value.\nFor example, the <code>hero</code> in <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"</code>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>children</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 的直接子元素。可以通过继续深入 <code>children</code> 来遍历这棵树。</p><p translation-origin=\"off\">      The immediate <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> children. Walk the tree by descending through <code>children</code>.</p>\n\n      <div class=\"alert is-helpful\">\n<p translation-result=\"on\">      <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 还有 <code>childNodes</code>，即 <code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> 对象列表。\n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 从 <code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> 对象衍生，而且通常节点（node）比元素多。测试者通常忽略赤裸节点。</p><p translation-origin=\"off\">      <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> also has <code>childNodes</code>, a list of <code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> objects.\n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> derives from <code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> objects and there are often\nmore nodes than elements. Testers can usually ignore plain nodes.</p>\n\n      </div>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>parent</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 的父级。如果 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 是根元素，<code>parent</code> 为 null。</p><p translation-origin=\"off\">      The <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> parent. Null if this is the root element.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>name</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      元素的标签名字，如果它是一个元素的话。</p><p translation-origin=\"off\">      The element tag name, if it is an element.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>triggerEventHandler</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      如果在该元素的 <code>listeners</code> 集合中有相应的监听器，就根据名字触发这个事件。\n第二个参数是该处理器函数所需的<em>事件对象</em>。参阅<a href=\"guide/testing-components-scenarios#trigger-event-handler\">前面</a>。</p><p translation-origin=\"off\">      Triggers the event by its name if there is a corresponding listener\nin the element's <code>listeners</code> collection.\nThe second parameter is the <em>event object</em> expected by the handler.\nSee <a href=\"guide/testing-components-scenarios#trigger-event-handler\">above</a>.</p>\n\n<p translation-result=\"on\">      如果事件缺乏监听器，或者有其它问题，考虑调用 <code>nativeElement.dispatchEvent(eventObject)</code>。</p><p translation-origin=\"off\">      If the event lacks a listener or there's some other problem,\nconsider calling <code>nativeElement.dispatchEvent(eventObject)</code>.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>listeners</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      元素的 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 属性以及/或者元素的事件属性所附带的回调函数。</p><p translation-origin=\"off\">      The callbacks attached to the component's <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> properties and/or the element's event properties.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>providerTokens</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      组件注入器的查询令牌。\n包括组件自己的令牌和组件的 <code>providers</code> 元数据中列出来的令牌。</p><p translation-origin=\"off\">      This component's injector lookup tokens.\nIncludes the component itself plus the tokens that the component lists in its <code>providers</code> metadata.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>source</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      source 是在源组件模板中查询这个元素的处所。</p><p translation-origin=\"off\">      Where to find this element in the source component template.</p>\n\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n<p>      <code>references</code></p>\n    </td>\n    <td>\n<p translation-result=\"on\">      与模板本地变量（比如 <code>#foo</code>）关联的词典对象，关键字与本地变量名字配对。</p><p translation-origin=\"off\">      Dictionary of objects associated with template local variables (e.g. <code>#foo</code>),\nkeyed by the local variable name.</p>\n\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"query-predicate\"></a>\n<p translation-result=\"on\"><code>DebugElement.query(predicate)</code> 和 <code>DebugElement.queryAll(predicate)</code> 方法接受一个条件方法，\n它过滤源元素的子树，返回匹配的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p><p translation-origin=\"off\">The <code>DebugElement.query(predicate)</code> and <code>DebugElement.queryAll(predicate)</code> methods take a\npredicate that filters the source element's subtree for matching <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>.</p>\n\n<p translation-result=\"on\">这个条件方法是任何接受一个 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 并返回真值的方法。\n下面的例子查询所有拥有名为 <code>content</code> 的模块本地变量的所有 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>：</p><p translation-origin=\"off\">The predicate is any method that takes a <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> and returns a <em>truthy</em> value.\nThe following example finds all <code>DebugElements</code> with a reference to a template local variable named \"content\":</p>\n\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"custom-predicate\" header=\"app/demo/demo.testbed.spec.ts\">\n// Filter for DebugElements with a #content reference\nconst contentRefs = el.queryAll( de => de.references.content);\n\n</code-example>\n<p translation-result=\"on\">Angular 的 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 类为常用条件方法提供了三个静态方法：</p><p translation-origin=\"off\">The Angular <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> class has three static methods for common predicates:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> <code>By.all</code> - 返回所有元素</p><p translation-origin=\"off\"><code>By.all</code> - return all elements.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <code>By.css(selector)</code> - 返回符合 CSS 选择器的元素。</p><p translation-origin=\"off\"><code>By.css(selector)</code> - return elements with matching CSS selectors.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <code>By.directive(directive)</code> - 返回 Angular 能匹配一个指令类实例的所有元素。</p><p translation-origin=\"off\"><code>By.directive(directive)</code> - return elements that Angular matched to an instance of the directive class.</p>\n\n</li>\n</ul>\n<code-example path=\"testing/src/app/hero/hero-list.component.spec.ts\" region=\"by\" header=\"app/hero/hero-list.component.spec.ts\">\n// Can find <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> either by css selector or by directive\nconst h2 = fixture.debugElement.query(By.css('h2'));\nconst directive = fixture.debugElement.query(By.directive(HighlightDirective));\n\n</code-example>\n\n  \n</div>\n\n\n<!-- links to this doc:\n - guide/testing\n - guide/testing-components-scenarios\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/NgForOf\n - api/core/ChangeDetectionStrategy#OnPush\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/DebugElement\n - api/core/DebugNode\n - api/core/Directive\n - api/core/NgModule\n - api/core/Output\n - api/core/Pipe\n - api/core/PlatformRef\n - api/core/Predicate\n - api/core/SchemaMetadata\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixtureAutoDetect\n - api/core/testing/MetadataOverride\n - api/core/testing/TestBed\n - api/core/testing/TestModuleMetadata\n - api/core/testing/discardPeriodicTasks\n - api/core/testing/fakeAsync\n - api/core/testing/flushMicrotasks\n - api/core/testing/getTestBed\n - api/core/testing/tick\n - api/core/testing/waitForAsync\n - api/platform-browser/By\n - guide/testing\n - guide/testing-components-scenarios#automatic-change-detection\n - guide/testing-components-scenarios#compile-components\n - guide/testing-components-scenarios#fake-async\n - guide/testing-components-scenarios#get-injected-services\n - guide/testing-components-scenarios#tick\n - guide/testing-components-scenarios#trigger-event-handler\n - guide/testing-components-scenarios#waitForAsync\n - guide/testing-components-scenarios#when-stable\n - guide/testing-utility-apis#component-fixture-api-summary\n - guide/testing-utility-apis#componentfixture-methods\n - guide/testing-utility-apis#componentfixture-properties\n - guide/testing-utility-apis#debug-element-details\n - guide/testing-utility-apis#debugelement\n - guide/testing-utility-apis#query-predicate\n - guide/testing-utility-apis#testbed-api-summary\n - guide/testing-utility-apis#testbed-class-summary\n - guide/testing-utility-apis#testing-utility-apis\n - guide/testing-utility-apis#the-componentfixture\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/testing-utility-apis.md?message=docs%3A%20请简述你的修改...\n - https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n-->"}